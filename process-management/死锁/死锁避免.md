## 死锁避免

### 安全状态

系统按照某种推进顺序(P1, P2, ..., Pn)为每个进程Pi分配所需资源，直到满足每个进程对资源的最大需求

若系统找不到一个安全序列，则称系统处于不安全状态

并发所有不安全状态都是死锁，当系统进入不安全状态后，可能进入死锁

![资源分配](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D.png "资源分配")

### 银行家算法

可利用资源矢量， Available
最大需求矩阵， Max
分配矩阵， Allocation
需求矩阵， Need
Need = Max - Allocation

假定系统中有5各进程{P0, P1, P2, P3, P4} 和 三类资源{A, B, C}，各种资源的数量分别为10, 5, 7，在T0时刻的资源分配情况见表

![安全性算法举例](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B.png "安全性算法举例")

先算出Need矩阵

![Need矩阵](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Need%E7%9F%A9%E9%98%B5.png "Need矩阵")

找出比Available向量小的行 P1 和 P3，暂时把P1加入安全序列

![Avaiable矩阵](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Avaiable%E7%9F%A9%E9%98%B5.png Avaiable矩阵)

释放P1所占有的资源，把P1进程对应的Allocation矩阵和Avaiable矩阵相加，得到新的可用矩阵

![更新后的Need矩阵](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84Need%E7%9F%A9%E9%98%B5.png 更新后的Need矩阵)

去掉了P1对应的一行
再用更新的Available向量和Need矩阵重复以上步骤，最终得到安全序列{P1, P3, P4, P2, P0}





## 死锁

- 死锁，指**多个进程因竞争资源**造成的一种僵局，若无外力作用，无法向前推进

### 死锁产生原因

#### 系统资源竞争

- 通常系统中拥有的不可剥夺资源，数量不足以满足多个进程运行的需要，使得进程在运行过程中，因争夺资源陷入僵局，如磁带机、打印机

- 只有对**不可剥夺资源的竞争**才可能**产生死锁**，对**可剥夺资源的竞争**不会引起死锁

#### 进程推进顺序不当

- 进程运行过程中，请求和释放资源的顺序不当，同样导致死锁

- 信号量使用不当也会造成死锁

- 进程间彼此相互等待对方发来的消息，结果会使得这些进程间无法继续向前推进

### 死锁产生的四个必要条件

#### 互斥条件

- 进程要求对所分配的资源进行排他性控制，在一段时间内某资源仅为一个进程所占有

- 若有其他进程请求该资源，则请求进程只能等待

#### 不剥夺条件

- 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能由获得该资源的进程自己释放

#### 请求和保持条件

- 进程已经保持了至少一个资源，又提出了新的资源要求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放

#### 循环等待条件

- 存在一种进程 资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程请求

### 典型例题

- 某系统中有三个并发进程都需要四个同类资源，则该系统必然不会发生死锁的最少资源是 10

- 当最少资源数为 9 的时候，三个进程都需要最后一个资源都不释放，必然发生死锁

- 某系统中共有11台磁带机，X个进程共享此磁带机设备，每个进程最多请求使用3台

- 则系统必然不会死锁的最大X值是 5，每个进程都请求2台磁带机，5个进程不会死锁，6个进程会死锁

- 某计算机系统中有8台打印机，由K个进程竞争使用，每个进程最多需要3台打印机

- 该系统可能会发生死锁的K的最小值是 4， 每个进程请求2台打印机，2\*4=8，死锁

- 多道程序技术要求进程间实现并发，需要实现进程调度保证CPU的工作效率，并发性的实现需要中断功能的支持

- 三个进程共享四个同类资源，这些资源的分配与释放只能一次一个

- 已知每一个进程最多需要两个该类资源，则该系统进程请求该类资源必然能得到

- 缺资源的那个进程可以等待另外进程的资源释放，就算每个进程都持有一个资源，也不会死锁

- 死锁的四个必要条件中，**无法破坏**的是，**互斥使用资源**

- 某个进程**主动释放资源**，**破坏了请求和保持条件**

- 某系统有n台互斥使用的同类设备，三个并发进程分别需要3、4、5台设备

- 可确保系统不发生死锁的设备数n最小为? 3-1 + 4-1 + 5-1 = 9，当9台设备时，会发生死锁，9+1=10 不会发生死锁

### 典型例题

- 某银行计算机系统要实现一个电子转账系统

- 基本的业务流程是: 首先对转出方和转入方的账户进行加锁，然后进行转账业务

- 最后对转出方和转入方的账户进行解锁。如果不采取任何措施，系统会不会发生死锁?

- 为什么?设计一个避免死锁的方法

- 系统会死锁，因为两个账户进行加锁操作是可以分割进行的

- 若此时有两个用户同时进行转账，P1先对账户A进行加锁，再申请账户B；P2先对账户B加锁，再申请账户A，此时产生死锁

- 解决方案: 采用资源顺序分配法对A、B账户进行编号，用户转账时只能按照编号由小到大进行加锁；

- 也可以采用资源预分配法，要求用户在使用资源之前将所有资源一次性申请到

- 银行家算法，如果某进程此刻提出一个Request，检查Request≤Need矩阵，Request≤Avaiable矩阵

- 二者皆满足，则找安全序列，找不到，那么该Request无效

- 假定某计算机系统有R1和R2两类可使用资源(其中R1有两个单位，R2有一个单位)

- 它们被进程P1和P2所共享，且已知两个进程均已下列顺序使用两类资源

- 申请R1->申请R2->申请R1->释放R1->释放R2->释放R1

- 试求出系统运行过程中可能到达的死锁点，并画出死锁点的资源分配图

- 随着两个进程向前推进，无论哪个进程执行完第二步，系统都将进入死锁状态

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Resource-allocation-map.png)

- 系统中有4个进程使用某类资源，系统能提供得该类资源数为9个，当每个进程申请的资源超过 **3** 个时，该系统可能发生死锁
- 申请3个资源时的临界情况，4个进程，每个进程持有2个资源，不会发生死锁

- 通常不采用从**非死锁进程**处抢夺资源解除死锁，因为从非死锁处抢夺资源可能造成更多进程死锁






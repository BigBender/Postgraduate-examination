## 死锁的处理策略

### 预防死锁

- 设置某些限制条件，破坏产生死锁的**四个必要条件**之一或几个

### 避免死锁

- 资源的**动态分配**过程中，用某种方法防止系统进入不安全状态

### 死锁的检测及解除

- 无需采取任何限制性措施，在运行过程中，**通过系统的检测机构及时检测出死锁的发生**，采取措施解除死锁

- 预防死锁和避免死锁都属于事先预防策略，但预防死锁的限制条件比较严格，实现较为简单，但往往导致系统效率低，资源利用率低

- 避免死锁的限制条件相对宽松，资源分配后需要通过算法判断是否进入不安全状态，实现起来复杂

![死锁处理策略比较](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5.png "死锁处理策略")

### 处理死锁的方法中，并发程度比较

- 并发程度**由上至下逐渐减小**

- 死锁检测方法

- 银行家算法

- 资源预分配法

#### 检测死锁，终止处于死锁状态的进程，释放该进程所占有的资源

- 允许死锁出现，即**允许进程最大限度地申请并分配资源**，直至出现死锁，再由系统出面解决

#### 银行家算法

- 允许进程自由申请资源，在某个进程申请时**检查系统是否处于安全状态**

- 若处于安全状态，则可立即分配，若不处于安全状态，拒绝分配

#### 静态预分配资源

- 进程在运行之前**申请所需的全部资源才**可开始运行

- 这样会使得**许多进程因申请不到资源**而无法开始

- 得到资源的进程也**并不是同时需要**所占的全部资源，资源浪费







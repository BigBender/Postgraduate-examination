## 进程的概念和特征

### 进程(Process)

### 引入进程的目的

- 实现操作系统的**并发行**和**共享性**，提高系统利用率和系统吞吐量

### 进程控制块 PCB（ProcessControlBlock）

- 由程序段、相关数据段和PCB构成了**进程映像**（进程实体）

**PCB**是进程存在的**唯一标志**!

- 进程，是进程实体的运行过程，是系统**资源分配和调度**的一个独立单位

#### PCB包含的信息

##### 进程标识符信息

- **唯一的标识符**，可以是字符串，也可以是一个数字

- UNIX系统中就是一个整型数。在进程创建时由系统赋予

-  进程标识符用于唯一的标识一个进程。一个进程通常有以下两种标识符

- 外部标识符。由创建者提供，通常是由字母、数字组成，往往是用户（进程）访问该进程使用

- 外部标识符便于记忆，如：计算进程、打印进程、发送进程、接收进程

- 内部标识符：为了方便系统使用而设置的。在所有的OS中，都为每一个进程赋予一个唯一的整数，作为内部标识符

- 它通常就是一个进程的符号，为了描述进程的家族关系，还应该设置父进程标识符以及子进程标识符

- 还可以设置用户标识符，来指示该进程由哪个用户拥有

##### 处理机状态信息

- 说明进程当前所处的状态

- 为了管理的方便，系统设计时会将相同的状态的进程组成一个队列，如就绪进程队列，等待进程则要根据等待的事件组成多个等待队列，如等待打印机队列、等待等

- 处理机状态信息主要是由**处理机各种寄存器中的内容**所组成

- 通用寄存器。又称为用户可视寄存器，可被用户程 序访问，用于暂存信息。

- 指令寄存器。存放要访问的下一条指令的地址。

- 程序状态字PSW。其中含有状态信息。（条件码、 执行方式、中断屏蔽标志等）

- 用户栈指针。每个用户进程有一个或若干个与之相 关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶

##### 进程调度信息

- 进程状态。指明进程当前的状态，作为进程调度和对换时的依据。

- 进程优先级。用于描述进程使用处理机的优先级别的一个整数，优先级高的进程优先获得处理机。

- 进程调度所需要的其他信息（进程已等待CPU的时间总和、进程已执行的时间总和）

- 事件，这是进程由执行状态转变为阻塞状态所等待发生的事件。（阻塞原因）

##### 进程上下文

- 是进程执行活动全过程的静态描述

- 包括计算机系统中与执行该进程有关的各种寄存器的值、程序段在经过编译之后形成的机器指令代码集、数据集及各种堆栈值和PCB结构

- 可按一定的执行层次组合，如用户级上下文、系统级上下文

- 进程存在的唯一标志：在进程的整个生命周期中，系统总是通过PCB对进程进行控制的，亦即，系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的，所以说，PCB是进程存在的唯一标志

### 进程特征

- 动态性

- 并发性

- 独立性

- 异步性

- 结构性

### 五种进程状态的转换(不带挂起状态)

![五状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png "五状态模型")

- 就绪->运行：获得**处理机资源**后，进程由就绪态转换为运行态

- 运行->就绪：处于运行态的进程在**时间片用完**后，让出处理机，变为就绪</br>在***可剥夺*** 操作系统中，当有**更高优先级**进程**就绪**，正运行的进程转为就绪态

- 运行->阻塞：当进程请求某资源的使用和分配或等待某一事件发生（I/O操作)
</br>由**目态**程序调用操作系统内核过程的形式

- 阻塞->就绪：**等待事件结束**，I/O操作结束或中断结束，由阻塞变为就绪

运行->阻塞，是一个**主动行为**

阻塞->就绪，是一个**被动行为**

### 就绪态和等待态的区别

就绪态，只缺少处理机，只要获得处理机资源就可以立即执行

等待态，进程需要其他资源（除了处理机）或等待某一事件

### 三态模型

![三状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Three-state-model.png)

- 运行：当一个进程在**处理机上运行**，称处于运行状态
</br>处于此状态的进程数木小于等于处理机的数目

- 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行

- 阻塞：等待或睡眠，一个进程正在等待某一时间发生(例如IO请求)而暂时停止运行，即使分配给进程也无法运行

### 五态模型(三状态模型上添加就绪挂起态和阻塞挂起态)

- 活跃就绪 挂起 静止就绪

- 静止就绪 激活 活跃就绪

- 活跃阻塞 挂起 静止阻塞

- 静止阻塞 激活 活跃阻塞

- 静止阻塞 -> 静止就绪

- 活跃阻塞 -> 活跃就绪

![五状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Five-state-model.png "五状态模型")

### 七态模型(在五态模型上添加新建态和等待态)

- 新建态：为新进程创建必要的管理信息，让进程进入就绪态，并没有被提交，处于新建态

- 终止态：完成善后操作

![七状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png "七状态模型")

### 进程的挂起

- 由于进程的不断创建，系统的资源已经**不能满足**进程运行的要求，这个时候就必须把某些进程挂起（suspend），**对换到磁盘镜像区中**，暂时**不参与**进程调度，起到**平滑系统操作负荷**的目的。
 
#### 引起进程挂起的原因

- 系统中的进程**均处于等待状态**，处理器**空闲**
</br>此时需要把一些阻塞进程对换出去，以**腾出足够的内存**装入就绪进程运行。
 
- 进程**竞争**资源，导致**系统资源不足**，负荷过重
</br>此时需要**挂起部分进程**以调整系统负,保证系统的实时性或让系统正常运行。 

- 把一些定**期执行的进程**（如审计程序、监控程序、记账程序）对换出去
</br>以减轻系统负荷。
 
- **用户要求**挂起自己的进程
</br>以便根据中间执行情况和中间结果进行某些调试、检查和改正。 

- ** 父进程要求**挂起自己的后代进程
</br>以进行某些检查和改正。
 
- 操作系统需要挂起某些进程，**检查运行中资源**使用情况，以改善系统性能
</br>或当系统**出现故障**或某些功能受到破坏时，需要挂起某些进程以**排除故障**。

#### 挂起态

- 挂起就绪态（ready,suspend) 挂起就绪态表明了进程**具备运行条件**但目前在**二级存储器(辅存)**中，只有当它被对换到**主存**才能被调度执行

- 挂起等待态（blocked,suspend）挂起等待态则表明了进程**正在等待**某一个事件且在**二级存储器(辅存)**中。

- 等待态—→挂起等待态：如果当前不存在就绪进程，那么至少有一个等待态进程将被对换出去成为挂起等待态；
</br>操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。

- 挂起等待态—→挂起就绪态：**引起进程等待的事件发生**之后，相应的挂起等待态进程将转换为挂起就绪态。
 
- 挂起就绪态—→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程**更高的优先级**，系统将把挂起就绪态进程转换成就绪态。

- 就绪态—→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。
 
- 挂起等待态—→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。
</br>但是在下面一种情况下，这一状态变化是可能的。
</br>当一个进程退出后，主存已经有了**一大块自由空间**,而某个挂起等待态进程具有**较高的优先级**并且操作系统已经得知**导致它阻塞的事件即将结束**，此时便发生了这一状态变化。
 
- 运行态—→挂起就绪态：当一个**具有较高优先级**的挂起等待态进程的等待事件结束后，它需要**抢占 CPU**，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。
</br>另外处于运行态的进程也可以自己挂起自己。

- 新建态—→挂起就绪态：考虑到系统**当前资源状况和性能要求**，可以决定新建的进程将被对换出去成为挂起就绪态。


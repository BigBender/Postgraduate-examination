## 进程控制

### 进程的生命周期

- 进程创建

- 进程运行

- 进程等待

- 进程唤醒

- 进程终止 

### 进程控制任务

- 进程的创建、终止、进程状态的转变等

### 进程控制一般由OS内核的原语（primitive）来实现

- 原语：由若干条指令构成的**原子操作**(atomic operation)过程。

- 许多系统调用是原语。但并不是所有的系统调用都是原语

### 进程创建

- 分配**唯一进程标识号**，申请空白PCB，为进程分配资源，（**资源不足则等待/阻塞**），初始化PCB，讲新进程插入就绪队列

#### 引起创建进程的事件

#### 由系统内核创建 

- 系统初始化

- 分时系统中用户登录

- 批处理系统中作业调度

#### 由应用程序自身创建

- 提供服务，用户请求创建进程 

- 应用请求，正在运行的进程执行了创建进程的系统调用

#### UNIX

- fork 系统调用: 创建一个子（新）进程，精确复制父进程

- exec系统调用: 在fork之后执行，用新的代码替换原父进程的代码

### 进程终止

- 根据**标识符**，检索PCB，终止对应进程以及所有子进程，**释放全部资源**，**将PCB从所在队列中移除**

#### 引起进程终止 的事件

##### 正常结束 UNIX: exit   Windows: ExitProcess 

##### 异常结束 

- 越界错误

- 保护错。

- 非法指令

- 特权指令错。

- 运行超时

- 等待超时

- 算术运算错

- I/O故障

##### 外界干预 Kill 

- 操作员或os干预

- 被父进程终止

- 父进程终止

### 进程阻塞和唤醒

#### 阻塞(进程的主动性行为)

- 根据标识号，查找对应PCB，自身调用有关阻塞原语，置为阻塞状态，**将PCB插入到相应事件的阻塞队列**中

- 进程由运行态变为阻塞态

- 引起处理机调度

#### 唤醒

- 根据标识号，从阻塞队列中移除相应进程的PCB，置为就绪状态，**将PCB插入到就绪队列**

- 唤醒原因：等待的事件到达

- **其他有关进程(例如用完并释放了该I/O设备的进程)**发送信号到某个或一组进程

- UNIX: kill

- kill可发送信号sig到某个或一组进程pid。其调用格式为：int kill(pid_tpid，intsig)

#### 引起阻塞和唤起的事件

- 请求系统服务

- 启动某种操作

- 新数据尚未到

- 无新工作可做 

### 三态模型

![三状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Three-state-model.png)

- 运行：当一个进程在**处理机上运行**，称处于运行状态
</br>处于此状态的进程数木小于等于处理机的数目

- 就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行

- 阻塞：等待或睡眠，一个进程正在等待某一时间发生(例如IO请求)而暂时停止运行，即使分配给进程也无法运行

### 五态模型(三状态模型上添加就绪挂起态和阻塞挂起态)

- 活跃就绪 挂起 静止就绪

- 静止就绪 激活 活跃就绪

- 活跃阻塞 挂起 静止阻塞

- 静止阻塞 激活 活跃阻塞

- 静止阻塞 -> 静止就绪

- 活跃阻塞 -> 活跃就绪

![五状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Five-state-model.png "五状态模型")

### 七态模型(在五态模型上添加新建态和等待态)

- 新建态：为新进程创建必要的管理信息，让进程进入就绪态，并没有被提交，处于新建态

- 终止态：完成善后操作

![七状态模型](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png "七状态模型")

### 典型例题

- 在实时系统中，当系统中的内存资源不够满足执行紧迫任务的需求时，操作系统可能会将正在运行的进程变为 精致就绪 状态
- 观察上图七状态模型，**运行状态不能直接切换到静止阻塞**(挂起阻塞)
- 只有阻塞态能直接切换到挂起阻塞态

- 当一个用户进程，需要使用打印机进行输出时，进程的状态由**运行态**变为**阻塞态**，打印结束后，产生一个打印中断，此时进程的状态会变为**就绪态**

### 进程的挂起

- 由于进程的不断创建，系统的资源已经**不能满足**进程运行的要求，这个时候就必须把某些进程挂起（suspend），**对换到磁盘镜像区中**，暂时**不参与**进程调度，起到**平滑系统操作负荷**的目的。
 
#### 引起进程挂起的原因

##### 终端用户请求

- **用户要求**挂起自己的进程

- 以便根据中间执行情况和中间结果进行某些调试、检查和改正

##### 父进程请求

- ** 父进程要求**挂起自己的后代进程

- 以进行某些检查和改正

##### 操作系统需要

- 挂起某些进程，**检查运行中资源**使用情况，以改善系统性能

- 或当系统**出现故障**或某些功能受到破坏时，需要挂起某些进程以**排除故障**。

##### 负荷调节需要

- 高优先级的进程要执行，而内存不空，系统将低优先级进程对换至外存

- 提高处理机效率：就绪进程表为空时，要提交新进程，而此时内存不空，需挂起阻塞态的进程

- 系统中的进程**均处于等待状态**，处理器**空闲**，此时需要把一些阻塞进程对换出去，以**腾出足够的内存**装入就绪进程运行
 
- 进程**竞争**资源，导致**系统资源不足**，负荷过重，此时需要**挂起部分进程**以调整系统负,保证系统的实时性或让系统正常运行。 

- 把一些**定期执行的进程**（如审计程序、监控程序、记账程序）对换出去

#### 挂起态

- 目的：**合理且充分地利用系统资源**

- 进程在挂起状态时，**进程没有占用内存空间**，仅映像在**磁盘**上

##### 执行过程

- 挂起原语：SUSPEND（）

- 挂起原语的执行过程：

- 从内存调到外存，改变进程的状态

- 若处于**活动就绪状态**，改为**静止就绪**

- 若处于**活动阻塞状态**，则改为**静止阻塞**

- 若正在执行，则转向调度程序重新调度

##### 进程的激活

- 原因：父进程或用户进程请求，或内存已有足够空间

- 执行过程：从外存调入内存，改变进程的状态

- 可能也会引起处理机调度

- 挂起就绪态（ready,suspend) 挂起就绪态表明了进程**具备运行条件**但目前在**二级存储器(辅存)**中，只有当它被对换到**主存**才能被调度执行

- 挂起等待态（blocked,suspend）挂起等待态则表明了进程**正在等待**某一个事件且在**二级存储器(辅存)**中。

- 等待态—→挂起等待态：如果当前不存在就绪进程，那么至少有一个等待态进程将被对换出去成为挂起等待态；
</br>操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。

- 挂起等待态—→挂起就绪态：**引起进程等待的事件发生**之后，相应的挂起等待态进程将转换为挂起就绪态。
 
- 挂起就绪态—→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程**更高的优先级**，系统将把挂起就绪态进程转换成就绪态。

- 就绪态—→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。
 
- 挂起等待态—→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。
</br>但是在下面一种情况下，这一状态变化是可能的。
</br>当一个进程退出后，主存已经有了**一大块自由空间**,而某个挂起等待态进程具有**较高的优先级**并且操作系统已经得知**导致它阻塞的事件即将结束**，此时便发生了这一状态变化。
 
- 运行态—→挂起就绪态：当一个**具有较高优先级**的挂起等待态进程的等待事件结束后，它需要**抢占 CPU**，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。
</br>另外处于运行态的进程也可以自己挂起自己。

- 新建态—→挂起就绪态：考虑到系统**当前资源状况和性能要求**，可以决定新建的进程将被对换出去成为挂起就绪态。




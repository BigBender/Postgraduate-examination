## 典型的调度算法

### (FCFS)先来先服务算法

- **不可剥夺**算法；对长作业有利，对CPU繁忙型作业有利，不利于I/O繁忙型作业

- 最简单的调度算法，既可以用于作业调度 ，也可以用于程序调度

- 当**作业调度**中采用该算法时，系统将**按照作业到达的先后次序**来进行调度，优先从"后备队列"中，选择**一个或多个位于队列头部**的作业，把他们调入内存，分配所需资源、创建进程

- 然后放入"就绪队列",直到该进程运行到完成或发生某事件堵塞后，进程调度程序才将处理机分配给其他进程

#### (Convoy effect)护航效果

- 遇到一个长作业，所有其他进程都等待一个大进程释放CPU，导致CPU和设备使用率变低

#### 典型例题

- 小细节，比如页的大小为 100字节，64 < 100 < 128，2^7=128，该页只需要用0~6位就能表示

- 底7位表示页内偏移，高位表示页号

##### 作业调度混合进程调度

- 主存100K，可变分区，采用FCFS，抢占式优先权(数值小者优先)
</br>分配主存优先分配低地址区作业装入主存后在完成之前不能在主存移动

<table style="border-collapse:collapse;">
<tr>
	<th>作业号</th>
	<th>进入输入井时间</th>
	<th>运行时间</th>
	<th>主存需求</th>
	<th>优先权</th>
	<th>进入内存时间</th>
	<th>完成时间</th>
	<th>周转时间(min)</th>
</tr>
<tr>		
	<td>1</td>
	<td>8: 00</td>
	<td>25分钟</td>
	<td>15K</td>
	<td>5</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>2</td>
	<td>8: 20</td>
	<td>10分钟</td>
	<td>30K</td>
	<td>4</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>3</td>
	<td>8: 25</td>
	<td>20分钟</td>
	<td>60K</td>
	<td>3</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>4</td>
	<td>8: 30</td>
	<td>20分钟</td>
	<td>20K</td>
	<td>2</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>5</td>
	<td>8: 35</td>
	<td>15分钟</td>
	<td>10K</td>
	<td>1</td>
	<td></td>
	<td></td>
	<td></td>
</table>

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Job-scheduling&Process-scheduling.png)

<table style="border-collapse:collapse;">
<tr>
	<th>作业号</th>
	<th>进入输入井时间</th>
	<th>运行时间</th>
	<th>主存需求</th>
	<th>优先权</th>
	<th>进入内存时间</th>
	<th>完成时间</th>
	<th>周转时间(min)</th>
</tr>
<tr>		
	<td>1</td>
	<td>8: 00</td>
	<td>25分钟</td>
	<td>15K</td>
	<td>5</td>
	<td>8: 00</td>
	<td>9: 30</td>
	<td>90 min</td>
</tr>
<tr>		
	<td>2</td>
	<td>8: 20</td>
	<td>10分钟</td>
	<td>30K</td>
	<td>4</td>
	<td>8: 20</td>
	<td>8: 30</td>
	<td>10 min</td>
</tr>
<tr>		
	<td>3</td>
	<td>8: 25</td>
	<td>20分钟</td>
	<td>60K</td>
	<td>3</td>
	<td>8: 30</td>
	<td>9: 25</td>
	<td>60 min</td>
</tr>
<tr>		
	<td>4</td>
	<td>8: 30</td>
	<td>20分钟</td>
	<td>20K</td>
	<td>2</td>
	<td>8: 30</td>
	<td>8: 50</td>
	<td>20 min</td>
</tr>
<tr>		
	<td>5</td>
	<td>8: 35</td>
	<td>15分钟</td>
	<td>10K</td>
	<td>1</td>
	<td>8: 50</td>
	<td>9: 05</td>
	<td>30 min</td>
</table>

- 带权周转时间 (作业的**周转时间**/**CPU提供服务的时间**)

- W1=90/25=3.6，W2=10/10=1，W3=60/20=3，W4=20/20=1，W5=30/15=2

- 平均带权周转时间 : (3.6+1+3+1+2)/5=9.35/5=2.12

#### 典型例题

- 某系统采用动态分区分配管理主存，供用户使用的主存200KB

- 作业装入主存后不能移动，系统有磁带机5台，外设采用静态分配策略

- 进程调度采用短作业优先，作业调度采用FCFS，忽略用户作业的IO时间

<table style="border-collapse: collapse;">
	<tr>
		<th>作业</th>
		<th>进入输入井时间</th>
		<th>估计执行时间</th>
		<th>主存需求</th>
		<th>磁带机需求</th>
	</tr>
	<tr>
		<td>J1</td>
		<td>10: 00</td>
		<td>40 min</td>
		<td>40KB</td>
		<td>3</td>
	</tr>
	<tr>
		<td>J2</td>
		<td>10: 20</td>
		<td>25 min</td>
		<td>120KB</td>
		<td>1</td>
	</tr>
	<tr>
		<td>J3</td>
		<td>10: 30</td>
		<td>35 min</td>
		<td>110KB</td>
		<td>2</td>
	</tr>
	<tr>
		<td>J4</td>
		<td>10: 35</td>
		<td>20 min</td>
		<td>30KB</td>
		<td>3</td>
	</tr>
	<tr>
		<td>J5</td>
		<td>10: 50</td>
		<td>10 min</td>
		<td>50 KB</td>
		<td>1</td>
	</tr>
</table>

- 求平均周转时间和平均带权周转时间

- 静态分配，一旦分配后，一直为该作业占用，直到该作业撤销

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/FCFS&tape-drive.png)

<table style="border-collapse: collapse;">
	<tr>
		<th>作业</th>
		<th>进入输入井时间</th>
		<th>估计执行时间</th>
		<th>开始执行时间</th>
		<th>完成时间</th>
	</tr>
	<tr>
		<td>J1</td>
		<td>10: 00</td>
		<td>40 min</td>
		<td>10: 00</td>
		<td>10: 40</td>
	</tr>
	<tr>
		<td>J2</td>
		<td>10: 20</td>
		<td>25 min</td>
		<td>10: 40</td>
		<td>11: 05</td>
	</tr>
	<tr>
		<td>J3</td>
		<td>10: 30</td>
		<td>35 min</td>
		<td>11: 25</td>
		<td>12: 00</td>
	</tr>
	<tr>
		<td>J4</td>
		<td>10: 35</td>
		<td>20 min</td>
		<td>11: 05</td>
		<td>11: 25</td>
	</tr>
	<tr>
		<td>J5</td>
		<td>10: 50</td>
		<td>10 min</td>
		<td>12: 00</td>
		<td>12: 10</td>
	</tr>
</table>

### (SJF)短作业优先算法

- 对长作业不利，可能导致"**饥饿**"现象，**平均等待时间和平均周转时间最少**

- 最短剩余(执行)时间优先调度，抢占式SJF

#### 典型例题

- 批处理系统中，内存只能装入3道作业

- 高级调度采用高优先权调度算法

- 低级调度采用抢占式SJF算法

- 表中优先级用于高级调度，数字越小优先权越高

<table style="border-collapse: collapse;">
	<tr>
		<th>作业名</th>
		<th>优先权</th>
		<th>到达时间</th>
		<th>估计运行时间</th>
		<th>进入内存时刻</th>
		<th>完成时刻</th>
	</tr>
	<tr>
		<td>A</td>
		<td>1</td>
		<td>8: 30</td>
		<td>8 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>B</td>
		<td>2</td>
		<td>8: 10</td>
		<td>25 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>C</td>
		<td>3</td>
		<td>8: 00</td>
		<td>40 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>D</td>
		<td>4</td>
		<td>8: 20</td>
		<td>10 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>E</td>
		<td>5</td>
		<td>8: 25</td>
		<td>5 min</td>
		<td></td>
		<td></td>
	</tr>
</table>

- **在驻留区未满的时候，先到的作业先进入**

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Minimum-remaining-time-priority.png)

<table style="border-collapse: collapse;">
	<tr>
		<th>作业名</th>
		<th>优先权</th>
		<th>到达时间</th>
		<th>估计运行时间</th>
		<th>进入内存时刻</th>
		<th>完成时刻</th>
	</tr>
	<tr>
		<td>A</td>
		<td>1</td>
		<td>8: 30</td>
		<td>8 min</td>
		<td>8: 30</td>
		<td>8: 38</td>
	</tr>
	<tr>
		<td>B</td>
		<td>2</td>
		<td>8: 10</td>
		<td>25 min</td>
		<td>8: 10</td>
		<td>8: 58</td>
	</tr>
	<tr>
		<td>C</td>
		<td>3</td>
		<td>8: 00</td>
		<td>40 min</td>
		<td>8: 10</td>
		<td>9: 28</td>
	</tr>
	<tr>
		<td>D</td>
		<td>4</td>
		<td>8: 20</td>
		<td>10 min</td>
		<td>8: 20</td>
		<td>8: 30</td>
	</tr>
	<tr>
		<td>E</td>
		<td>5</td>
		<td>8: 25</td>
		<td>5 min</td>
		<td>8: 38</td>
		<td>8: 43</td>
	</tr>
</table>

#### 典型例题(短作业作业调度+优先数进程调度+打印机静态资源) 

- 一个多道批处理系统，作业调度采用"短作业优先"调度算法，进程调度采用"优先数抢占式"调度算法，优先数越小优先级越高

- 系统拥有一台打印机，采用静态方法分配，忽略系统调度开销，现有作业序列到达系统

<table style="border-collapse: collapse;">
	<tr>
		<th>作业编号</th>
		<th>到达系统时间</th>
		<th>要求执行时间</th>
		<th>需打印机数</th>
		<th>进程优先级</th>
	</tr>
	<tr>
		<td>J1</td>
		<td>14: 00</td>
		<td>40 min</td>
		<td>1 台</td>
		<td>4</td>
	</tr>
	<tr>
		<td>J2</td>
		<td>14: 20</td>
		<td>30 min</td>
		<td>0 台</td>
		<td>2</td>		
	</tr>
	<tr>
		<td>J3</td>
		<td>14: 30</td>
		<td>50 min</td>
		<td>1 台</td>
		<td>3</td>
	</tr>
	<tr>
		<td>J4</td>
		<td>14: 50</td>
		<td>20 min</td>
		<td>0 台</td>
		<td>5</td>
	</tr>
	<tr>
		<td>J5</td>
		<td>15: 00</td>
		<td>10 min</td>
		<td>1 台</td>
		<td>1</td>
	</tr>
</table>

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Static-assignment-plus-short-job-priority.png)


#### 典型例题

##### 最短剩余(执行)时间优先进程调度(抢占式短作业优先)

- 某系统采用抢占式短作业优先的进程调度算法，给出5个进程的到达时间和要求运行时间

<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>到达时刻</th>
		<th>估计运行时间</th>
		<th>开始执行时刻</th>
		<th>完成时刻</th>
	</tr>
	<tr>
		<td>P1</td>
		<td>0: 00</td>
		<td>4h</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>P2</td>
		<td>1: 00</td>
		<td>1h</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>P3</td>
		<td>3: 00</td>
		<td>2h</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>P4</td>
		<td>6: 00</td>
		<td>5h</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>P5</td>
		<td>8: 00</td>
		<td>2h</td>
		<td></td>
		<td></td>
	</tr>
</table>

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Minimum-remaining-time.png)

<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>到达时刻</th>
		<th>估计运行时间</th>
		<th>开始执行时刻</th>
		<th>完成时刻</th>
		<th>周转时间</th>
		<th>带权周转时间</th>
	</tr>
	<tr>
		<td>P1</td>
		<td>0: 00</td>
		<td>4h</td>
		<td>0: 00</td>
		<td>5: 00</td>
		<td>5h</td>
		<td>1.25h</td>
	</tr>
	<tr>
		<td>P2</td>
		<td>1: 00</td>
		<td>1h</td>
		<td>1: 00</td>
		<td>2: 00</td>
		<td>1h</td>
		<td>1h</td>
	</tr>
	<tr>
		<td>P3</td>
		<td>3: 00</td>
		<td>2h</td>
		<td>5: 00</td>
		<td>7: 00</td>
		<td>4h</td>
		<td>2h</td>
	</tr>
	<tr>
		<td>P4</td>
		<td>6: 00</td>
		<td>5h</td>
		<td>7: 00</td>
		<td>14: 00</td>
		<td>8</td>
		<td>1.6</td>
	</tr>
	<tr>
		<td>P5</td>
		<td>8: 00</td>
		<td>2h</td>
		<td>8: 00</td>
		<td>10: 00</td>
		<td>2h</td>
		<td>1h</td>
	</tr>
</table>

#### 典型例题 

##### 作业调度混合进程调度

- 有一个两道的批处理操作系统，作业调度采用最短作业优先的调度算法，进程调度采用基于优先数的抢占式调度算法

<table style="border-collapse: collapse;">
<tr>
	<th>作业</th>
	<th>进入时间</th>
	<th>估计运行时间</th>
	<th>优先数</th>	
</tr>
<tr>
	<td>JOB1</td>
	<td>10: 00</td>
	<td>40 min</td>
	<td>5</td>
</tr>
<tr>
	<td>JOB2</td>
	<td>10: 20</td>
	<td>30 min</td>
	<td>3</td>
</tr>
<tr>
	<td>JOB3</td>
	<td>10: 30</td>
	<td>50 min</td>
	<td>4</td>
</tr>
<tr>
	<td>JOB4</td>
	<td>10: 60</td>
	<td>20 min</td>
	<td>6</td>
</tr>
</table>

- 优先数数值越小优先级越高

- 列出所有作业进入内存时间及运行结束时间

- 计算作业平均周转时间和带权平均周转时间

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Job-scheduling&Process-scheduling-1.png)

<table style="border-collapse: collapse;">
<tr>
	<th>作业</th>
	<th> 进入输入井时间</th>
	<th>进入内存时间</th>
	<th>运行时间</th>	
	<th>结束时间</th>
	<th>周转时间</th>
	<th>带权周转时间</th>
</tr>
<tr>
	<td>JOB1</td>
	<td>10: 00</td>
	<td>10: 00</td>
	<td>10: 00-10: 20 </br>10: 50-11: 10</td>
	<td>11:10</td>
	<td>70</td>
	<td>7/4</td>
</tr>
<tr>
	<td>JOB2</td>
	<td>10: 20</td>
	<td>10: 20</td>
	<td>10: 20-10: 50</td>
	<td>10: 50</td>
	<td>30</td>
	<td>1</td>
</tr>
<tr>
	<td>JOB3</td>
	<td>10: 30</td>
	<td>11: 10</td>
	<td>11: 10-12: 00</td>
	<td>12: 00</td>
	<td>90</td>
	<td>9/5</td>
</tr>
<tr>
	<td>JOB4</td>
	<td>10: 50</td>
	<td>10: 50</td>
	<td>12: 00-12: 20</td>
	<td>12: 20</td>
	<td>90</td>
	<td>9/2</td>
</tr>
</table>

- 带权平均周转时间 (7/4 + 1 + 9/5 + 9/2)/4=(1.75+1+1.8+4.5)/4=9.5/4=2.26

### 优先级调度算法

- **非剥夺式**优先级调度算法

- **剥夺式**优先级调度算法，分为 **静态**优先级 和 **动态**优先级

- 完全不可抢占或用户态不可抢占

- 内核完全不可抢占

- 内核部分可抢占

- 完全可抢占或内核完全可抢占

#### 主要问题

- 无穷阻塞(饥饿)，可以运行但缺乏CPU，一直在等待CPU

- 优先级调度算法会使低优先级进程无穷等待CPU

### 高响应比优先调度算法(非抢占式的)

![响应比](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%93%8D%E5%BA%94%E6%AF%94.png "响应比")

- **作业等待时间相同**，要求服务时间越短，响应比越高，**有利于短作业**

- **当要求服务时间相同**，等待时间越长，响应比越高，克服了**饥饿**状态，兼顾**长作业**

#### 典型例题(高响应比优先)

- 某系统进程采用高响应比优先的调度算法，如下表所示

- 写出各进程的完成时间并计算系统的平均周转时间

<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>提交时间</th>
		<th>运行时间(分钟)</th>
	</tr>
	<tr>
		<td>P1</td>
		<td>8: 00</td>
		<td>120</td>
	</tr>
	<tr>
		<td>P2</td>
		<td>8: 50</td>
		<td>50</td>
	</tr>
	<tr>
		<td>P3</td>
		<td>9: 00</td>
		<td>10</td>
	</tr>
	<tr>
		<td>P4</td>
		<td>9: 50</td>
		<td>20</td>
	</tr>
</table>

- 响应比=(等待+执行)/执行

![响应比](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/High-response-ratio.png)


<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>提交时间</th>
		<th>运行时间(分钟)</th>
		<th>完成时间(分钟)</th>
		<th>平均周转时间(分钟)</th>
	</tr>
	<tr>
		<td>P1</td>
		<td>8: 00</td>
		<td>120</td>
		<td>10: 00</td>
		<td>120</td>
	</tr>
	<tr>
		<td>P2</td>
		<td>8: 50</td>
		<td>50</td>
		<td>11: 00</td>
		<td>130</td>
	</tr>
	<tr>
		<td>P3</td>
		<td>9: 00</td>
		<td>10</td>
		<td>10: 10</td>
		<td>70</td>
	</tr>
	<tr>
		<td>P4</td>
		<td>9: 50</td>
		<td>20</td>
		<td>11: 20</td>
		<td>90</td>
	</tr>
</table>

- 平均周转时间: (120+130+70+90)/4=102.5 min

### 时间片轮转调度算法

- 主要用于**分时系统**，所有就绪进程按到达时间先后次序**排成一个队列**

- 选择就绪队列中第一个进程执行，**FCFS**，**剥夺式**

- 时间片用完进程未完成运行，必须释放处理机

#### 算法描述

- 将系统中所有的就绪进程**按照FCFS原则**，排成一个队列

- 每次调度时将CPU分派给队首进程，让其执行一个时间片。在一个时间片结束时，发生时钟中断

- 调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程

- 时间片的长度从几个ms到几百ms

- 进程可以未使用完一个时间片，就出让CPU（如阻塞）

#### 时间片长度的确定

- 时间片长度过长－>退化为FCFS算法

- 时间片长度过短－>用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长

- 就绪进程的数目：数目**越多**，时间片**越小**

- 系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长

#### 进程优先级

- 降低进程优先级的合理时机是，**进程的时间片用完**

#### 典型例题

- 假设某操作系统采用时间片轮转调度策略，时间片大小为100ms，就绪进程队列的平均长度为5

- 如果在系统中运行一个需要在CPU上执行0.8s时间的程序

- 则该程序的平均周转时间是  

- 5个进程以一共需要4s，排在队列尾的周转时间4s，...，排在队列头的周转时间3.6s

- 平均周转时间，19/5=3.8s     

- 平均等待时间，(3.2 + 3.1 + 3.0 + 2.9 + 2.8)/5=3.0s

#### 典型例题(CPU利用率)

- 系统中，每个进程在IO阻塞之前的运行时间为T，一次进程切换的系统开销时间为S

- 若采用时间片长度为Q的时间片轮转法，对下列各种情况算出CPU利用率

- Q = ∞，CPU利用率 = T/(T + S)

- Q > T，CPU利用率 = T/(T + S)

- T > Q > S，CPU利用率 = Q/(Q + S)

- Q = S，CPU利用率 = 50%

- Q->0，CPU利用率 = 0 

### 多级反馈队列调度算法

![多级反馈队列调度算法](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png "多级反馈队列调度算法")

#### 动态调整进程优先级和时间片大小

- 设置多个就绪队列，各个队列**赋予不同优先级**，队列优先级**逐次降低**

- 优先级**越高**，时间片**越小**

- 放入第一级队列末尾，执行完，放入第二级队列末尾

- 仅当第一级队列为空，调度程序往下一级调度

#### 算法性能

- **终端**型作业用户：**短作业**优先

- **短批处理**作业用户：周转时间**较短**

- **长批处理**作业用户：经过前面队列的部分执行，不会长期得不到处理

#### 优点：优势

- 为提高系统吞吐量和缩短平均周转时间而照顾短进程

- 为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程

- 不必估计进程的执行时间，动态调节

### 实时调度算法

#### 最早截止时间优先 EDF（Earliest Deadline First）

- 根据任务的开始截止时间确定任务的优先级。具有最早截止时间的任务排在队列的最前面

- 即可用于抢占式调度，又可用于非抢占式调度

#### 最低松弛度优先LLF（Least Laxity First）算法

- 任务的**紧急程度愈高**，该任务的**优先级愈高**

- 松弛度 = 必须完成时间-本身运行时间-当前时间

- 如，t=0时，某任务在200ms时必须完成，他本身执行的时间是100ms，则其松弛度为100ms。

- LLF算法按松弛度排就绪队列，松弛度最低的排在队列最前面，优先被调度执行。

- LLF主要用于可抢占调度方式中





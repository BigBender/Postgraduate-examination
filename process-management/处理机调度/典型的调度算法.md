## 典型的调度算法

### (FCFS)先来先服务算法

**不可剥夺**算法；对长作业有利，对CPU繁忙型作业有利，不利于I/O繁忙型作业

#### (Convoy effect)护航效果

遇到一个长作业，所有其他进程都等待一个大进程释放CPU，导致CPU和设备使用率变低

#### 典型例题

##### 作业调度混合进程调度

- 主存100K，可变分区，采用FCFS，抢占式优先权(数值小者优先)
</br>分配主存优先分配低地址区作业装入主存后在完成之前不能在主存移动

<table style="border-collapse:collapse;">
<tr>
	<th>作业号</th>
	<th>进入输入井时间</th>
	<th>运行时间</th>
	<th>主存需求</th>
	<th>优先权</th>
	<th>进入内存时间</th>
	<th>完成时间</th>
	<th>周转时间(min)</th>
</tr>
<tr>		
	<td>1</td>
	<td>8: 00</td>
	<td>25分钟</td>
	<td>15K</td>
	<td>5</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>2</td>
	<td>8: 20</td>
	<td>10分钟</td>
	<td>30K</td>
	<td>4</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>3</td>
	<td>8: 25</td>
	<td>20分钟</td>
	<td>60K</td>
	<td>3</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>4</td>
	<td>8: 30</td>
	<td>20分钟</td>
	<td>20K</td>
	<td>2</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>5</td>
	<td>8: 35</td>
	<td>15分钟</td>
	<td>10K</td>
	<td>1</td>
	<td></td>
	<td></td>
	<td></td>
</table>

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Job-scheduling&Process-scheduling.png)

<table style="border-collapse:collapse;">
<tr>
	<th>作业号</th>
	<th>进入输入井时间</th>
	<th>运行时间</th>
	<th>主存需求</th>
	<th>优先权</th>
	<th>进入内存时间</th>
	<th>完成时间</th>
	<th>周转时间(min)</th>
</tr>
<tr>		
	<td>1</td>
	<td>8: 00</td>
	<td>25分钟</td>
	<td>15K</td>
	<td>5</td>
	<td>8: 00</td>
	<td>9: 30</td>
	<td>90 min</td>
</tr>
<tr>		
	<td>2</td>
	<td>8: 20</td>
	<td>10分钟</td>
	<td>30K</td>
	<td>4</td>
	<td>8: 20</td>
	<td>8: 30</td>
	<td>10 min</td>
</tr>
<tr>		
	<td>3</td>
	<td>8: 25</td>
	<td>20分钟</td>
	<td>60K</td>
	<td>3</td>
	<td>8: 30</td>
	<td>9: 25</td>
	<td>55 min</td>
</tr>
<tr>		
	<td>4</td>
	<td>8: 30</td>
	<td>20分钟</td>
	<td>20K</td>
	<td>2</td>
	<td>8: 30</td>
	<td>8: 50</td>
	<td>20 min</td>
</tr>
<tr>		
	<td>5</td>
	<td>8: 35</td>
	<td>15分钟</td>
	<td>10K</td>
	<td>1</td>
	<td>8: 50</td>
	<td>9: 05</td>
	<td>15 min</td>
</table>

- 带权周转时间 (作业的**周转时间**/**CPU提供服务的时间**)

- W1=90/25=3.6，W2=10/10=1，W3=55/20=2.75，W4=20/20=1，W5=15/15=1

- 平均带权周转时间 : (3.6+1+2.75+1+1)/5=9.35/5=1.87

### (SJF)短作业优先算法

对长作业不利，可能导致"**饥饿**"现象，**平均等待时间和平均周转时间最少**

#### 最短剩余时间优先调度

**抢占式**的SJF算法

### 优先级调度算法

- **非剥夺式**优先级调度算法

- **剥夺式**优先级调度算法，分为 **静态**优先级 和 **动态**优先级

#### 主要问题

- 无穷阻塞(饥饿)，可以运行但缺乏CPU，一直在等待CPU

- 优先级调度算法会使低优先级进程无穷等待CPU

### 高响应比优先调度算法

![响应比](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%93%8D%E5%BA%94%E6%AF%94.png "响应比")

**作业等待时间相同**，要求服务时间越短，响应比越高，**有利于短作业**

**当要求服务时间相同**，等待时间越长，响应比越高，克服了**饥饿**状态，兼顾**长作业**

### 时间片轮转调度算法

主要用于**分时系统**，所有就绪进程按到达时间先后次序**排成一个队列**

选择就绪队列中第一个进程执行，**FCFS**，**剥夺式**

时间片用完进程未完成运行，必须释放处理机

### 多级反馈队列调度算法

![多级反馈队列调度算法](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png "多级反馈队列调度算法")

### 动态调整进程优先级和时间片大小

- 设置多个就绪队列，各个队列**赋予不同优先级**，队列优先级**逐次降低**

- 优先级**越高**，时间片**越小**

- 放入第一级队列末尾，执行完，放入第二级队列末尾

- 仅当第一级队列为空，调度程序往下一级调度

### 优势

- **终端**型作业用户：**短作业**优先

- **短批处理**作业用户：周转时间**较短**

- **长批处理**作业用户：经过前面队列的部分执行，不会长期得不到处理








## 典型的调度算法

### (FCFS)先来先服务算法

**不可剥夺**算法；对长作业有利，对CPU繁忙型作业有利，不利于I/O繁忙型作业

#### (Convoy effect)护航效果

遇到一个长作业，所有其他进程都等待一个大进程释放CPU，导致CPU和设备使用率变低

#### 典型例题

##### 作业调度混合进程调度

- 主存100K，可变分区，采用FCFS，抢占式优先权(数值小者优先)
</br>分配主存优先分配低地址区作业装入主存后在完成之前不能在主存移动

<table style="border-collapse:collapse;">
<tr>
	<th>作业号</th>
	<th>进入输入井时间</th>
	<th>运行时间</th>
	<th>主存需求</th>
	<th>优先权</th>
	<th>进入内存时间</th>
	<th>完成时间</th>
	<th>周转时间(min)</th>
</tr>
<tr>		
	<td>1</td>
	<td>8: 00</td>
	<td>25分钟</td>
	<td>15K</td>
	<td>5</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>2</td>
	<td>8: 20</td>
	<td>10分钟</td>
	<td>30K</td>
	<td>4</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>3</td>
	<td>8: 25</td>
	<td>20分钟</td>
	<td>60K</td>
	<td>3</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>4</td>
	<td>8: 30</td>
	<td>20分钟</td>
	<td>20K</td>
	<td>2</td>
	<td></td>
	<td></td>
	<td></td>
</tr>
<tr>		
	<td>5</td>
	<td>8: 35</td>
	<td>15分钟</td>
	<td>10K</td>
	<td>1</td>
	<td></td>
	<td></td>
	<td></td>
</table>

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Job-scheduling&Process-scheduling.png)

<table style="border-collapse:collapse;">
<tr>
	<th>作业号</th>
	<th>进入输入井时间</th>
	<th>运行时间</th>
	<th>主存需求</th>
	<th>优先权</th>
	<th>进入内存时间</th>
	<th>完成时间</th>
	<th>周转时间(min)</th>
</tr>
<tr>		
	<td>1</td>
	<td>8: 00</td>
	<td>25分钟</td>
	<td>15K</td>
	<td>5</td>
	<td>8: 00</td>
	<td>9: 30</td>
	<td>90 min</td>
</tr>
<tr>		
	<td>2</td>
	<td>8: 20</td>
	<td>10分钟</td>
	<td>30K</td>
	<td>4</td>
	<td>8: 20</td>
	<td>8: 30</td>
	<td>10 min</td>
</tr>
<tr>		
	<td>3</td>
	<td>8: 25</td>
	<td>20分钟</td>
	<td>60K</td>
	<td>3</td>
	<td>8: 30</td>
	<td>9: 25</td>
	<td>55 min</td>
</tr>
<tr>		
	<td>4</td>
	<td>8: 30</td>
	<td>20分钟</td>
	<td>20K</td>
	<td>2</td>
	<td>8: 30</td>
	<td>8: 50</td>
	<td>20 min</td>
</tr>
<tr>		
	<td>5</td>
	<td>8: 35</td>
	<td>15分钟</td>
	<td>10K</td>
	<td>1</td>
	<td>8: 50</td>
	<td>9: 05</td>
	<td>15 min</td>
</table>

- 带权周转时间 (作业的**周转时间**/**CPU提供服务的时间**)

- W1=90/25=3.6，W2=10/10=1，W3=55/20=2.75，W4=20/20=1，W5=15/15=1

- 平均带权周转时间 : (3.6+1+2.75+1+1)/5=9.35/5=1.87

### (SJF)短作业优先算法

对长作业不利，可能导致"**饥饿**"现象，**平均等待时间和平均周转时间最少**

#### 最短剩余时间优先调度

**抢占式**的SJF算法

#### 典型例题

##### 最短剩余时间优先进程调度(抢占式短作业优先)

<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>到达时刻</th>
		<th>估计运行时间</th>
		<th>开始执行时刻</th>
		<th>完成时刻</th>
	</tr>
	<tr>
		<td>A</td>
		<td>8: 30</td>
		<td>8 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>B</td>
		<td>8: 10</td>
		<td>25 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>C</td>
		<td>8: 00</td>
		<td>40 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>D</td>
		<td>8: 20</td>
		<td>10 min</td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td>E</td>
		<td>8: 25</td>
		<td>5 min</td>
		<td></td>
		<td></td>
	</tr>
</table>

#### 典型例题 

##### 作业调度混合进程调度

- 有一个两道的批处理操作系统，作业调度采用最短作业优先的调度算法，进程调度采用基于优先数的抢占式调度算法

<table style="border-collapse: collapse;">
<tr>
	<th>作业</th>
	<th>进入时间</th>
	<th>估计运行时间</th>
	<th>优先数</th>	
</tr>
<tr>
	<td>JOB1</td>
	<td>10: 00</td>
	<td>40 min</td>
	<td>5</td>
</tr>
<tr>
	<td>JOB2</td>
	<td>10: 20</td>
	<td>30 min</td>
	<td>3</td>
</tr>
<tr>
	<td>JOB3</td>
	<td>10: 30</td>
	<td>50 min</td>
	<td>4</td>
</tr>
<tr>
	<td>JOB4</td>
	<td>10: 60</td>
	<td>20 min</td>
	<td>6</td>
</tr>
</table>

- 优先数数值越小优先级越高

- 列出所有作业进入内存时间及运行结束时间

- 计算作业平均周转时间和带权平均周转时间

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Job-scheduling&Process-scheduling-1.png)

<table style="border-collapse: collapse;">
<tr>
	<th>作业</th>
	<th> 进入输入井时间</th>
	<th>进入内存时间</th>
	<th>运行时间</th>	
	<th>结束时间</th>
	<th>周转时间</th>
	<th>带权周转时间</th>
</tr>
<tr>
	<td>JOB1</td>
	<td>10: 00</td>
	<td>10: 00</td>
	<td>10: 00-10: 20 </br>10: 50-11: 10</td>
	<td>11:10</td>
	<td>70</td>
	<td>7/4</td>
</tr>
<tr>
	<td>JOB2</td>
	<td>10: 20</td>
	<td>10: 20</td>
	<td>10: 20-10: 50</td>
	<td>10: 50</td>
	<td>30</td>
	<td>1</td>
</tr>
<tr>
	<td>JOB3</td>
	<td>10: 30</td>
	<td>11: 10</td>
	<td>11: 10-12: 00</td>
	<td>12: 00</td>
	<td>90</td>
	<td>9/5</td>
</tr>
<tr>
	<td>JOB4</td>
	<td>10: 50</td>
	<td>10: 50</td>
	<td>12: 00-12: 20</td>
	<td>12: 20</td>
	<td>90</td>
	<td>9/2</td>
</tr>
</table>

- 带权平均周转时间 (7/4 + 1 + 9/5 + 9/2)/4=(1.75+1+1.8+4.5)/4=9.5/4=2.26

### 优先级调度算法

- **非剥夺式**优先级调度算法

- **剥夺式**优先级调度算法，分为 **静态**优先级 和 **动态**优先级

#### 主要问题

- 无穷阻塞(饥饿)，可以运行但缺乏CPU，一直在等待CPU

- 优先级调度算法会使低优先级进程无穷等待CPU

### 高响应比优先调度算法(非抢占式的)

![响应比](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%93%8D%E5%BA%94%E6%AF%94.png "响应比")

**作业等待时间相同**，要求服务时间越短，响应比越高，**有利于短作业**

**当要求服务时间相同**，等待时间越长，响应比越高，克服了**饥饿**状态，兼顾**长作业**

#### 典型例题(高响应比优先)

- 某系统进程采用高响应比优先的调度算法，如下表所示

- 写出各进程的完成时间并计算系统的平均周转时间

<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>提交时间</th>
		<th>运行时间(分钟)</th>
	</tr>
	<tr>
		<td>P1</td>
		<td>8: 00</td>
		<td>120</td>
	</tr>
	<tr>
		<td>P2</td>
		<td>8: 50</td>
		<td>50</td>
	</tr>
	<tr>
		<td>P3</td>
		<td>9: 00</td>
		<td>10</td>
	</tr>
	<tr>
		<td>P4</td>
		<td>9: 50</td>
		<td>20</td>
	</tr>
</table>

- 响应比=(等待+执行)/执行

![响应比](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/High-response-ratio.png)


<table style="border-collapse: collapse;">
	<tr>
		<th>进程</th>
		<th>提交时间</th>
		<th>运行时间(分钟)</th>
		<th>完成时间(分钟)</th>
		<th>平均周转时间(分钟)</th>
	</tr>
	<tr>
		<td>P1</td>
		<td>8: 00</td>
		<td>120</td>
		<td>10: 00</td>
		<td>120</td>
	</tr>
	<tr>
		<td>P2</td>
		<td>8: 50</td>
		<td>50</td>
		<td>11: 00</td>
		<td>130</td>
	</tr>
	<tr>
		<td>P3</td>
		<td>9: 00</td>
		<td>10</td>
		<td>10: 10</td>
		<td>70</td>
	</tr>
	<tr>
		<td>P4</td>
		<td>9: 50</td>
		<td>20</td>
		<td>11: 20</td>
		<td>90</td>
	</tr>
</table>

- 平均周转时间: (120+130+70+90)/4=102.5 min

### 时间片轮转调度算法

主要用于**分时系统**，所有就绪进程按到达时间先后次序**排成一个队列**

选择就绪队列中第一个进程执行，**FCFS**，**剥夺式**

时间片用完进程未完成运行，必须释放处理机

### 多级反馈队列调度算法

![多级反馈队列调度算法](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png "多级反馈队列调度算法")

### 动态调整进程优先级和时间片大小

- 设置多个就绪队列，各个队列**赋予不同优先级**，队列优先级**逐次降低**

- 优先级**越高**，时间片**越小**

- 放入第一级队列末尾，执行完，放入第二级队列末尾

- 仅当第一级队列为空，调度程序往下一级调度

### 优势

- **终端**型作业用户：**短作业**优先

- **短批处理**作业用户：周转时间**较短**

- **长批处理**作业用户：经过前面队列的部分执行，不会长期得不到处理








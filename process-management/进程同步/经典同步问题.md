## 经典同步问题

### 生产者-消费者问题

#### 问题描述

一组生产者和一组消费者共享一个初时为空、大小为n的缓冲区

只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待

只有缓冲区不空时，消费者才能从中取出消息，否则必须等待

缓冲区是临界资源，只允许一个生产者放入消息或者从一个消费者从中取出消息

#### 关系分析

生产者和消费者**对缓冲区访问是互斥关系**，同时生产者和消费者又是一个相互协作的关系只有生产者生产之后，消费者才能消费，他们也是**同步关系**

#### 思路

缓冲区需要加互斥锁，两进程之间需要加同步锁

```cpp
// 信号量设置
semaphore mutex = 1;
semaphore empty = n;// 缓冲区空闲单位
semaphore full = 0;// 缓冲区占用单位

producer(){
	while(1){
		生产数据
		P(empty());// 获取缓冲区空闲单位
		P(mutex);// 开锁
		将数据放入缓冲区
		V(mutex);// 上锁
		V(full);// 缓冲区占用单位+1
	}
}

consumer(){
	while(1){
		P(full);// 获取缓冲区占有单位
		P(mutex);// 开锁
		从缓冲区取出数据
		V(mutex);// 上锁
		V(empty);// 缓冲区空闲单位+1
		消费数据
	}

}
```

注意对empty和full变量的操作要在对**mutex变量(开关锁)操作之外**

#### 问题描述

桌子上有一只盘子，每次只能向其中放入一个水果

爸爸放苹果，妈妈放橘子，儿子等吃盘子中的橘子，女儿等吃盘子中的苹果

只有盘子为空时，爸爸或妈妈向盘子中放一个水果

仅当盘子中有自己需要的水果时儿子或女儿从盘子中取出

#### 问题分析

爸爸放苹果与女儿吃苹果同步，妈妈放橘子与儿子吃橘子同步

![进程同步间关系](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%90%8C%E6%AD%A5%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB.png "进程同步间关系")

#### 思路

盘子是互斥变量，苹果和橘子均只有一个，初值为0，表示盘子为空，为1表示盘子中有一个苹果或者橘子

```cpp

// 信号量设置

semaphore apple = 0, orange = 0, plate = 1;

dad(){
	while(1){
		生产一个苹果
		P(plate);// 获取盘子空闲位置
		放苹果
		V(apple);// 苹果数量+1
	}
}

mom(){
	while(1){
		生产一个橘子
		P(plate);// 获取盘子空闲位置
		放橘子
		V(orange);// 橘子数量+1
	}
}

son(){
	while(1){
		P(orange);// 获取一个橘子
		拿走橘子
		V(plate);// 归还盘子空闲位置
		吃橘子
	}
}

daughter(){
	while(1){
		P(apple);// 获取一个苹果
		拿走苹果
		V(plate);// 归还盘子空闲位置
		吃苹果
	}
}
```
### 读者-写者问题

#### 问题描述

有读者和写者两组并发进程，共享一个文件

当两个或以上的读进程同时访问共享数据时不会产生副作用

但若某个 写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误

因此要求：允许多个读者可以同时对文件执行读操作

只允许一个写者往文件中写信息

任一写者在完成写操作之前不允许其他读者或写者工作

写者执行写操作前，应让已有读者和写者全部退出

#### 关系分析

读、写进程互斥，写进程之间互斥

#### 思路整理

写者和任何进程互斥，读者需要与写者互斥，和读者之间的同步

使用一个读者计数器，判断是否有读者读文件，当有读者时是无法写文件的

```cpp

// 信号量设置

int count = 0;// 读者计数器
semaphore mutex = 1;// count变量的锁
semaphore rw = 1;// 读者和写者互斥访问文件

writer(){
	while(1){
		P(rw);
		写入
		V(rw);
	}
}

reader(){
	while(1){
		P(mutex);// count 变量开锁
		if(count == 0){
			P(rw);
		}		
		count++;
		V(mutex);// count 变量上锁
		读取
		P(mutex);// count 变量开锁
		count--;		
		if(count == 0){
			V(rw);
		}
		V(mutex);// count 变量上锁
	}
}
```

以上算法是读进程优先的，当存在读进程时，写操作将被延迟

只要有一个读进程活跃，随后而来的读进程都允许访问文件，可能导致写进程长时间等待，被"饿死"

增加一个信号量，只有在无写进程执行的情况下才允许读进程再次运行

```cpp

int count = 0;// 读者计数器
semaphore mutex = 1;// count变量的锁
semaphore rw = 1;// 读者和写者互斥访问文件
semaphore w = 1;// 写优先锁

writer(){
	while(1){
		P(w);// 打开优先锁
		P(rw);
		写入
		V(rw);
		V(w);// 关闭优先锁
	}
}

reader(){
	while(1){
		P(w);// 打开优先锁
		P(mutex);// count 变量开锁
		if(count == 0){
			P(rw);
		}		
		count++;
		V(mutex);// count 变量上锁
		V(w);// 关闭优先锁
		读取
		P(mutex);// count 变量开锁
		count--;		
		if(count == 0){
			V(rw);
		}
		V(mutex);// count 变量上锁
	}
}
```

### 哲学家问题

#### 问题描述

- 圆桌上5名哲学家，每两个哲学家之间摆一根筷子，桌子中间是一碗米饭

- 哲学家饥饿时，拿起左、右两根筷子，若筷子已在他人手上，等待

- 饥饿的哲学加只有同时那道了两根筷子才能开始进餐

- 进餐完毕后，放下筷子继续思考

![哲学家进餐](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90.png "哲学家进餐")

#### 思路

有五个进程，拿到左右两根筷子不造成死锁或饥饿现象，让他们同时拿起两个筷子，并对哲学家的动作指定规则

```cpp

// 信号量设置

semaphore chopstick[5] = {1, 1, 1, 1, 1}
Pi(){
	do{
		P(chopstick[i]);// 取左边筷子
		P(chopstick[(i+1)%5]);// 取右边筷子
		进餐
		V(chopstick[i]);// 归还左边的筷子
		V(chopstick[(i + 1)%5]);// 归还右边的筷子
		思考
	}while(1);	
}

```

以上算法，分别拿起他们左边筷子时，筷子被拿光了，想要拿右边筷子时，全被阻塞了，出现了死锁

为了防止死锁发生，对哲学家进程施加一些限制条件，比如至多允许四个哲学家同时进餐

仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子

当左右两边的筷子都可用时，才允许他抓起筷子

```cpp

semaphore chopstick[5] = {1, 1, 1, 1, 1};
semaphore mutex = 1;
Pi(){
	do{
		P(mutex);			// 开锁
		P(chopstick[i]);
		P(chopstick[(i+1)%5]);
		V(mutex);			// 上锁
		进餐
		V(chopstick[i]);
		V(chopstick[(i+1)%5]);	
	}while(1);	
}

```

### 吸烟者问题

#### 问题描述

假设一个系统有三个抽烟者进程和一个供应者进程

每个抽烟者不停卷烟并抽掉它，但是要卷起并抽一只烟，抽烟者需要有三种材料：烟草、纸和胶水

三个抽烟者中，第一个拥有烟草、第二个拥有纸，第三个拥有胶水

供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上

拥有剩下那种材料地抽烟者卷一根烟并抽调它，并给供应者一个信号告诉完成了

供应者就会放另外两种材料在桌子上，这种过程一直重复

#### 问题分析

供应者与三个抽烟者是同步关系，抽烟者之间是互斥的

#### 思路

四个进程，供应者作为生产者向三个抽烟者提供材料，抽烟者作为消费者

```cpp

semaphore offer1 = 0;// 烟草与纸的资源组合
semaphore offer2 = 0;// 烟草和胶水的资源组合
semaphore offer3 = 0;// 纸和胶水的资源组合
semaphore smoked = 0;// 是否已完成抽烟

process provider(){
	while(1){		
		random = Math.random();
		random %= 3;
		if(random == 0){
			V(offer1);
		}else if(random == 1){
			V(offer2);
		}else{
			V(offer3);
		}
		P(smoked);
	}
}

smoker1(){
	while(1){
		P(offer3);
		抽烟
		V(smoked)
	}
}

smoker2(){
	while(1){
		P(offer2);
		抽烟
		V(smoked)
	}
}

smoker1(){
	while(1){
		P(offer1);
		抽烟
		V(smoked)
	}
}

```










## 信号量

### 信号量类型

- 不是所有信号量都是整型变量，常用的是记录型信号量，记录型信号量是一个整体

### PV操作，对应wait(S) 和 signal(S)

- 整型信号量，S用于表示资源数目的整型量

![wait&signal](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/wait%26signal.png "wait&signal")

- 只要S<=0，程序就会忙等

- 记录型信号量

```cpp

typedef struct {
    int count;	     
	struct  process *queue; 
}semaphore;

```

- 一个整数值s.count：其初值表示某类资源的数目（又称为“资源信号量”)

- 一个进程等待队列s.queue，是阻塞在该信号量的各个进程的PCB链成的队列

![记录型信号量](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Recording-semaphore.png)

- 当S<0，进程调用block原语，**自我阻塞**，实现了"让权等待"

### 利用信号量实现同步

![利用信号量实现同步](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.png "利用信号量实现同步")

### 利用信号量实现互斥

![利用信号量实现互斥](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5.png "利用信号量实现互斥")

### 利用信号量实现前驱

![前驱图](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%89%8D%E9%A9%B1%E5%9B%BE.png "前驱图")

![前驱图](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%89%8D%E9%A9%B1%E5%9B%BE1.png "前驱图")

![前驱实现](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%89%8D%E9%A9%B1%E5%AE%9E%E7%8E%B0.png "前驱实现")

### 典型例题

- 对信号S的P操作中，使进程进入相应阻塞队列等待的条件是 S<0，**P对S的操作是先减1再判定**，所以进入阻塞队列的条件是 S<0

- 具有N个进程的系统中，允许M个进程(N≥M≥1)同时进入它们的共享区，与该共享区对应的信号量S的值变化的范围，[M-N, M]

- 当资源量小于0时，表示所有资源已经全部用完，**等待的进程数就是资源量的绝对值**

- 一个正在访问临界资源的进程由于申请等待IO操作而被中断时，可以**允许**其他进程**抢占处理器**，但**不得进入该进程的临界区**

- 非共享数据不属于临界资源，临界资源是**互斥共享资源**

- 公用队列属于临界资源，临界资源与共享资源的区别在于在一段时间内能否允许被多个进程访问(并发使用)

- P操作可能导致进程阻塞，因为需求的资源若不可用，则进程进入阻塞状态

- 原语是不可分割的指令序列

- 一个进程由程序、数据及PCB组成，其中共享程序段必须用可重入编码编写

- PV操作都是原语，**不可被中断**

- 对于两个并发进程，设互斥信号量为mutex(初值为1)，若mutex=0，则表示有一个进程进入临界区

- 没有等待进入的进程，若有等待的进程，则mutex会变成负数

- 当一个进程因在互斥信号量mutex上执行V(mutex)操作而导致唤醒另一个进程时

- 执行V操作后mutex的值为小于等于0，因为系统原来存在一个等待进入临界区的进程，mutext≤-1

- 管程中的signal操作与信号量机制中的V操作不同，信号量机制中的V操作一定会改变信号量的S=S+1

- 而管程中的sinal操作是针对某个条件变量的，若不**存在因该条件而阻塞的进程**，signal不产生任何影响，与V操作不一样

- PV操作不是系统调用，只是一种低级通信原语

- P、操作是在信号量上进行的

```cpp

// 进程P1                 // 进程P2
int x = 0                int x = 0;
Thread1(){               Thread3(){
	int a;					int a;
	a = 1;					a=x;
	x += 1;					x += 3;		
}						 }
Thread2(){				 Thread4(){
	int a;					int b;
	a=2;                    b = x;
	x += 2;                 x += 4;
}                        }

```

- 进程P1的 x += 1和 x += 2的执行会影响最终结果，需要加互斥锁

- 进程P1和进程P2，共享初值为1的变量x，P1对x+1，P2对x-1

```cpp

// 加1操作					     	// 减1操作
1. load R1,x// 取x到寄存器R1中		4. load R2,x// 取x到寄存器R1中
2. inc R1							5. dec R2
3. store x,R1// 将R1的内容存入x		6. store x,R2// 将R2的内容存入x

```

- 1,2,3,4,5,6 结果为1；1,2??????????

```cpp

do{
	......
	while(TSL(&lock));
	critical secton;
	lock=FALSE;	
	......
}while(TRUE);

```

- 上述代码，当进程退出临界区时值lock为FALSE，会负责唤醒处于就绪状态的进程

- 若等待进入临界区的进程会一直停留在执行while(TSL(&lock))的循环中，不会主动放弃CPU

- 在非剥夺方式下，运行进程**执行V原语**后，**其状态不变**
- 执行V原语的进程原本是运行态，会使value的值+1，执行完后，value的值大于0，不做任何操作
- 若value的值小于等于0，会唤醒一个原本处于等待状态的进程，使其进入就绪态
- 非剥夺调度方式下，原进程会继续运行，直到运行结束，再调用下一个进程








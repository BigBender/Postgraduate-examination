## 外存分配方式(文件实现)

### 目的

- 提高存储空间的利用率

- 提高文件的访问速度

### 连续分配

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Continuous-allocation.png)

- 每个文件分配一组相邻接的盘块，也称物理顺序文件

- 要求每个文件在磁盘上占有**一组连续的块**

- 定义一个线性排序，使作业访问磁盘时需要的**寻道数和寻道时间最小**

- 如果文件有n块长并从位置b开始，那么该文件将占有块 b，b+1，...，b+n-1

- 随着使用，磁盘碎片增多，性能下降，需要磁盘整理

- 优点：顺序访问速度快，定位容易，只需记录第一个簇的位置

- 可以通过紧缩(compact)将外存空闲空间合并成连续的区域。
 
- 缺点: 需要连续的空间，当文件长度变化难于处理，即必须事先知道文件的长度

#### 连续分配支持顺序访问和直接访问

- 实现简单，存取速度快

- 缺点：文件长度不宜动态增加，一但需要增加，就需要大量移动盘块

- 随着文件的分配与删除会产生**外部碎片**，很难确定文件所需空间大小，**适用于长度**固定的文件

### 链接分配

- 采取**离散分配**的方式

- 消除了外部碎片，提高了磁盘空间利用率

- 可动态分配盘块，对文件增、删、改也很方便

#### 隐式链接分配

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Implicit-link-assignment.png)

- 每个文件对应一个磁盘块的链表

- 磁盘块分布在磁盘任何地方，除最后一个盘块外，**每个盘块都有指向下一个盘块的指针**，**对用户透明**

- 目录包括文件第一块的指针和最后一块的指针

- 分配给文件的盘块不连续，在每个簇中有指向下一个簇的指针

- 目录中只存放第一和最后一块的簇号（盘块号）

- 解决顺序文件的离散存储的问题

- 链接分配**只适合于顺序访问**，**随机访问效率差，可靠性差**

#### 隐式链接分配的相关计算

- 硬盘大小16GB，盘块的大小为1KB

- 问至少有多少字节用于保存下一个盘块的块号

- 16GB=2^34B，一个盘块 1KB=2^10B，总共有 2^24 个盘块

- 指针要表示完整的24位需要至少三个字节 (一个字节，8位，三个字节，24位)

- 问支持的单个文件的最大长度为多少字节

- 一个盘块大小 1KB=2^10B=1024B，由指针最少的字节数知，内容最多占 1021B 

- 2^24 个盘块，最多有 2^24*1021B 大小

- 问若文件A所占用的前4个盘块号依次为67、32、90、100，文件A的字节偏移量2000

- 对应的物理盘块号和块内位移量分别为多少？

- 逻辑块号，⌊2000/1021⌋=1，(盘块号从0开始编号)第一个盘块号物理块号是32

- 块内偏移量，2000%1021=979

#### 隐式链接分配缺点

- **无法直接访问**盘块，只能**通过指针顺序**访问文件

- 盘块指针**消耗了一定存储空间**

- **稳定性差**，系统由于软/硬件错误导致链表中指针丢失或损坏，导致文件数据丢失

#### 显式链接分配

- 用于链接文件各物理块的指针，从每个物理块的块末尾提取出来

- **显式地放在内存一张链接表**中，该表只有一张

- 凡是属于某一文件的**第一个盘块号**或者每一条链的**链首指针对应的盘块号**，填入**FCB**的**物理地址**字段

- 查找记录的过程在**内存中进行**，显著提高了**检索速度**，大大减少了访问磁盘的次数

- 分配给文件的所有盘块号都在该表中，该表称为**文件分配表**(File Allocation Table, **FAT**)

- **例如**，按照上面隐式链接的所给的数据，链接表中第1项的内容就为10，第10项内容就为25，依次类推

#### 显式链接分配相关计算

- 给出一个字节偏移量，要求计算逻辑块号，物理块号和块内偏移量

- 字节偏移量整除一个盘块字节数 -> 逻辑块号， 通过查FAT表得到 物理块号

- 字节偏移量整除一个盘块字节数 -> 块内偏移量

### 簇

- **文件存储单位**：簇（cluster）――簇又称为部分(portion)

- 文件的存储空间通常由多个独立的簇组成，而每个簇包含**若干个连续的外存存储单位**（如扇区sector）
#### 簇的大小

- 两个极端：大到能容纳整个文件，小到一个外存存储块（一个扇区）

- 簇较大：提高I/O访问性能，减小管理开销

- 簇较小：簇内的碎片浪费较小，特别是大量小文件时有利

#### 两种确定簇大小的方法

- 簇大小**可变**，其上限较大：I/O访问性能较好

- 但簇大小可变，**文件存储空间的管理困难**，因为要指明每个簇的尺寸

- 簇大小**固定**，较小：文件存储空间使用灵活，但**I/O访问性能下降**，文件管理所需**空间开销较大**

### 索引分配

![索引分配](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png "索引分配")

- 链接分配解决了连续分配的外部碎片和文件大小管理问题

- 但是链接分配**不能用有效支持直接访问**(FAT除外)

- 把每个文件的所有盘块号都**集中放在一起构成索引块(表)**

- 索引块，磁盘块**地址数组**

#### 典型例题，直接索引分配

- 某文件系统采用直接索引分配方式为文件分配磁盘空间，为每个文件分配一个索引块用于记录分配给该文件的所有盘块号

- 文件目录项中记录该索引块的盘块号

- 硬盘大小为16TB，盘块大小为4KB

- 索引块中块号最少占用多少字节？

- 16TB=2^44B，4KB=2^12，一共有 2^44/2^12=2^32 个盘块，需要用32位来表示，索引块占4字节

- 该文件系统中支持的单个文件的最大长度为多少

- 一个盘块4KB=2^12B，可以存放 2^12/4 = 2^10 个索引，所以单个文件的最大长度为 2^10\*2^12 = 2^22B  

- 若文件索引块号依次为 23、25、32、20，文件A的字节偏移量 12500 对应的物理块号和块内位移量

- 块号 ⌊12500/2^12⌋=3，3号块是20(块号从0开始编号)， 块内偏移 12500%2^12=212 

#### 查找文件的过程

索引块的**第i个条目**指向文件的**第i个块**，目录条目**包括索引块的地址**

要读第i个块，通过索引块的第i个条目的**指针**来查找和读入所需的块

#### 创建文件的过程

- 索引块所有指针都设为空，首次写入第i个块时，**先从空闲区间中取得一个块**，再**将地址写到**索引块的第i个条目

#### 索引分配优点

- **索引支持直接访问**，没有外部碎片问题

#### 索引分配缺点

- 由于索引分配，增加了系统存储空间的开销，索引块大小是一个重要问题

- 在能够支持大文件的情况下索引块尽可能小

#### 索引块大小确定机制

- 链接方案，一个索引块通常为磁盘块，本身**能直接读写**，为处理大文件，多个索引块链接起来

- 多层索引，第一层索引块指向第二层索引块，第二层索引块再指向文件块

- 根据最大文件大小的要求，可以继续到第三层或第四层

- 例如，4096的块，能在索引块中存入1024个4B指针，两层索引允许(1024)^2=1048576个数据2^12*2^20=4GB

- 混合索引，既采用直接地址又采用单级索引分配或两级索引分配

#### 混合索引相关计算

- 采用混合索引方式，FCB有13个地址项，第0~9个地址项为直接地址，第10个地址项一次间接地址

- 第11个地址项为二次间接地址，第12个地址项为三次间接地址。每个盘块大小512字节

- 若盘块号需要用3个字节来描述而每个盘块最多存放170个盘块地址

- 问允许的最大文件长度是多少

- 所有的盘块数: 10 + 170 + 170^2 + 170^3 = 4942080

- 允许的最大文件长度: 512\*4942080=2471040KB

- 求文件字节偏移量5000，15000，150000转换成物理块号和物理偏移

- ⌊5000/512⌋=9，5000%512=392，9≤9，逻辑号 9

- 在直接地址中的第9个地址项取得物理地址

- 块内偏移392

- ⌊15000/512⌋=29，15000%512=152，9<29≤170，在一次间接地址中，逻辑号29

- 减掉前面的地址(直接地址项)，29-10=19 一次间接地址的第19个地址项对应的物理地址

- 块内偏移152

- ⌊150000/512⌋=292，15000%512=496，292在二次间接地址中， 

- 减掉前面的地址(直接地址项+一次间接地址项)，物理块号对应一次地址项中 292-180=112 号

- 块内偏移496

#### 典型例题

- 某个文件系统，采用混合索引分配方式为文件分配磁盘空间，FCB中共有13个地址项，每个盘块的大小为512字节

- 若每个盘块号用2个字节来描述，则该文件系统需要设置几级间接索引

- 2B 占用16位 2^16个盘块，512B=2^9，2^9\*2^9 > 2^16需要设置二级间接索引

- 如果每个盘块号需要用3个字节来描述，共允许每个盘块中存放170个盘块地址，FCB采用10个直接地址项

- 1个一级间接索引，1个二级间接索引，1个三级间接索引，大小为32MB的文件，共需占用多少个盘块

- 32MB=2^25B，文件内容需要 2^25/2^9=2^16=65536块

- 直接索引10块，一级索引分配170块，二级索引分配170^2=28900块，剩下36456块

- ⌈36456/170⌉ =215，三级索引需要1个一级索引，2个二级索引(一个170项，一个45项)，三级索引项有215

- 共需要 65536(文件内容) + 1(一级索引) + 171(二级索引) + 218(三级索引) 个盘块

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Mixed-index.png)

#### 典型例题

- 假设某个文件FCB已在内存，其他信息均在外存，为了访问该文件中某个位置的内容，最少和最多需要几次访盘

- 最少情况，若需要访问的块在直接地址项，只需要一次访盘(先访存找地址，再到磁盘按照地址找到内容)

- 最多情况，若需要访问的块在三次间接地址项，需要四次访盘(第一次读三次间接地址块，第二次读二次间接地址块，第三次读一次间接地址块，访存读直接地址块，第四次到按照物理地址到磁盘找到内容)

#### 典型例题

- 某文件系统采用多级索引的方式组织文件的数据存放，i_node结构有13个地址项

- 直接索引10项，一次间接索引1项，二次间接索引1项，三次间接索引1项

- 数据块的大小4KB，磁盘地址用4B表示

- 这个文件系统允许的最大文件长度是多少

- 物理块大小为4KB，数据大小为4B，每个物理块可存储地址数 4KB/4B=1024

- 直接索引项目 10块，一级间接索引 1024 块，二级间接索引 1024^2 块，三级间接索引 1024^3 块

- 最大文件长度为 4KB\*(10 + 1024 + 1024^2 + 1024^3)≈4TB

- 一个2GB的文件，在文件系统中实际占用多少空间

- 2GB/4KB = 2^30/2^12=2^18B = 512x1024，在二次间接索引项中

- 一次间接索引项使用了1个间接索引块 

- 1 + ⌈(152x1024 - 10 - 1024)/1024⌉≈512个间接索引块 (最左的1表示二次间址块)

- 间接索引块所占的空间大小为 (1 + 512)x4KB=2MB + 4KB

- 文件的i_node数据结构占用 13x4B=52B，该文件实际占用磁盘空间大小 2GB+2MB+4KB+52B

![文件三种分配方式比较](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%96%87%E4%BB%B6%E4%B8%89%E7%A7%8D%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png "文件三种分配方式比较")

## 文件存储管理

- 要为新文件分配存储空间，系统必须以某种数据结构记住存储空间的使用情况

- 外存空闲空间管理的数据结构通常称为磁盘分配表(disk allocation table)，分配的**基本单位是簇**

### 文件存储器空间的划分和初始化

- 一个文件存储在一个文件卷中，文件卷可以是物理盘的一部分，也可以是整个物理盘，也可以是多个物理盘

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/The-relationship-between-logical-volume&physical-disk.png)

### 逻辑卷与物理盘的关系

- 在文件卷中，文件数据信息的空间(文件区)和存放文件控制信息的FCB空间是分离的

- 系统中有不同的文件管理模块，访问不同格式逻辑卷中的文件

### 文件存储器空间管理

- 文件存储设备分为许多大小相同的物理块，以块为单位交换信息

- 文件存储设备的管理**实质上是对空闲块的组织和管理**，包括空闲块组织、分配与回收

#### 空闲表法

- **连续分配方式**，系统为外存上所有空闲区建立一张**空闲盘块表**，将所有空闲区按起始\*盘块号递增\*的次序排列

![空闲盘块表](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E7%A9%BA%E9%97%B2%E7%9B%98%E5%9D%97%E8%A1%A8.png "空闲盘块表")

- 回收用户释放的存储空间，采取类似于回收内存的方法

- 考虑回收区是否与空闲表插入点的前区和后区相邻，对相邻接者予以合并

#### 空闲链表法

- 将所有空闲盘区拉成一条空闲链

##### 空闲盘块链，将所有空闲空间，**以盘块为单位**拉成一条链

- 申请文件时，从**链首开始**，依次摘下适当数目的空闲盘块给用户

- 当用户删除文件释放空间时，将要回收的盘块**依次插入空闲盘块链的末尾**

##### 空闲盘区链，将所有空闲空间，以盘区(**由若干个盘块组成一个盘区**)为单位拉成一条链

- 每个盘区含有指向下个盘区的**指针**和指明本**盘区大小的信息**，分配方法通常采用**首次适应法**

- 回收时，要将**回收区与相邻接的空闲盘区相合并**

#### 位示图法

![位示图法](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%BD%8D%E7%A4%BA%E5%9B%BE.png "位示图法")

- 利用二进制和字长表示空闲盘块，1表示已分配，0表示空闲

#### 盘块的分配：

以下公式，位示图片是从1开始编号

- 顺序扫描位示图，找出一个或一组值为"0"的二进制位

- 第i行，第j列相应盘块号为 b = n(i - 1) + j  n 表示字长

- 修改对应位，将其置为一，map[i, j]=1

#### 盘块回收：

- i = (b-1)/n + 1

- j = (b-1)%n + 1

- 修改位示图，令 map[i, j] = 0

#### 典型例题

- 一台16位字长的计算机，采用页式存储管理

- 主存储器共有8000块(块号为0~7999)，系统采用位示图法管理主存空间

- 主存块号7500对应的字号和块号(均从0开始)各是多少

- **注意!**，7500是块号，不是第7500块！

- ⌊7501/16⌋=468，前468行满列(0~467)，字号为468

- 7501%16=13，块号为12

### 成组链接法

- 空闲表法和空闲链表法不适合大型文件系统，因为会使空闲表或空闲链表太大

- **UNIX系统**常采用成组链接法，结合了空闲表和空闲链表，**克服了表大的缺点**

#### 成组链接法结构

![成组链接法](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Group-link-method.png)

![成组链接法结构图](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Group-link-method-structure.png)

#### 成组链接法空间分配

- 内存中栈中元素结点依次出栈，分配给文件

- 当内存中栈的结点全部出栈以后，将最后一个出栈的结点的块中的栈保存到内存(超级快)中，更新指针和栈中元素数量n

![成组链接法空间分配](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Group-link-method-space-allocation.png)

#### 成组链接法空间回收

- 如果内存中(超级块)的栈没有满，就将盘块压入栈中

![成组链接法空间分配](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Group-link-method-space-recycling.png)

- 如果内存中(超级块)的栈已满，把超级块的内容复制到新回收的盘块中，更新指针，更新超级块中的指针指向新的新回收的盘块

![成组链接法空间分配](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Group-link-method-space-recycling2.png)

#### 大致思想

- 第一个空闲扇区，保存一个顺序的n个空闲扇区地址

- 后一个空闲扇区则**保存另一顺序空闲扇区的地址**，直到所有空闲扇区**均予以链接**

- 系统保存一个指向第一个空闲扇区的指针

![成组链接法](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png "成组链接法")

#### 优点：可以迅速找到大批空闲块地址

### UNIX中的超级块

表示文件存储器空闲空间的"位向量"表或**第一个**成组链块以及卷的目录区，文件区划分信息都放在**辅存储器**中

一般放在**卷头位置**，在UNIX中称为"**超级块**"

对卷中文件操作前，"超级块"**预先读入系统空闲主存**，经常**保持**主存"超级块"与辅存卷中"超级块"**一致性**


### 典型例题

#### 成组链接法

- 每个盘块大小为4KB，空闲盘块号栈中最多可放6个空闲盘块号。栈底存放当前可用的空闲盘块数

- 当前空闲盘块栈的内容，以及后续两组空闲盘块号如下图所示

<table style="border-collapse: collapse;">
	<tr>
		<th>空闲盘块号栈</th>
		<th>10号盘块中存放的空闲盘块号</th>
		<th>23号盘块中存放的空闲盘块号</th>
	</tr>
	<tr>
		<td>栈底</td>
		<td>栈底</td>
		<td>栈底</td>
	</tr>
	<tr>
		<td>3</td>
		<td>6</td>
		<td>5</td>
	</tr>
	<tr>
		<td>10</td>
		<td>23</td>
		<td>0</td>
	</tr>
	<tr>
		<td>19</td>
		<td>22</td>
		<td>41</td>
	</tr>
	<tr>
		<td>11</td>
		<td>29</td>
		<td>45</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>32</td>
		<td>47</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>26</td>
		<td>49</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>28</td>
		<td>43</td>
	</tr>
	<tr>
		<td>栈顶</td>
		<td>栈顶</td>
		<td>栈顶</td>
	</tr>
</table>

- 该文件系统当前有多少个空闲盘块?

- 3+6+5 = 14

- 用户创建了文件A，大小43KB，画出为文件A分配空间后图变化

- ⌈43/4⌉=11块，需要分配11块

- 由图知，一共有三组空闲盘块，第一组有2块，第二组有6块，第三组有5块

- 从超级块中依次出栈11、19、10号，将10号盘块中存放的空闲盘块内容存储到超级块中

- 还剩下8块需要分配

<table style="border-collapse: collapse;">
	<tr>
		<th>空闲盘块号栈</th>
		<th>23号盘块中存放的空闲盘块号</th>
	</tr>
	<tr>
		<td>栈底</td>
		<td>栈底</td>
	</tr>
	<tr>
		<td>6</td>
		<td>5</td>
	</tr>
	<tr>
		<td>23</td>
		<td>0</td>
	</tr>
	<tr>
		<td>22</td>
		<td>41</td>
	</tr>
	<tr>
		<td>29</td>
		<td>45</td>
	</tr>
	<tr>
		<td>32</td>
		<td>47</td>
	</tr>
	<tr>
		<td>26</td>
		<td>49</td>
	</tr>
	<tr>
		<td>28</td>
		<td>43</td>
	</tr>
	<tr>
		<td>栈顶</td>
		<td>栈顶</td>
	</tr>
</table>

- 从超级块中分配28、26、32、29、22、23，将23号盘块空闲盘块内容存储到超级快中

- 还剩两块需要分配

<table style="border-collapse: collapse;">
	<tr>
		<th>空闲盘块号栈</th>
	</tr>
	<tr>
		<td>栈底</td>
	</tr>
	<tr>
		<td>5</td>
	</tr>
	<tr>
		<td>0</td>
	</tr>
	<tr>
		<td>41</td>
	</tr>
	<tr>
		<td>45</td>
	</tr>
	<tr>
		<td>47</td>
	</tr>
	<tr>
		<td>49</td>
	</tr>
	<tr>
		<td>43</td>
	</tr>
	<tr>
		<td>栈顶</td>
	</tr>
</table>

- 从超级块中分配43、49，至此11个块分配完成

<table style="border-collapse: collapse;">
	<tr>
		<th>空闲盘块号栈</th>
	</tr>
	<tr>
		<td>栈底</td>
	</tr>
	<tr>
		<td>5</td>
	</tr>
	<tr>
		<td>0</td>
	</tr>
	<tr>
		<td>41</td>
	</tr>
	<tr>
		<td>45</td>
	</tr>
	<tr>
		<td>47</td>
	</tr>
	<tr>
		<td>▢</td>
	</tr>
	<tr>
		<td>▢</td>
	</tr>
	<tr>
		<td>栈顶</td>
	</tr>
</table>

- 之后用户删除文件B，文件B占用的盘块号依次为51、52、53、54、55，画出系统回收文件B占用的看空间

- 一共有5个块需要回收

<table style="border-collapse: collapse;">
	<tr>
		<th>空闲盘块号栈</th>
	</tr>
	<tr>
		<td>栈底</td>
	</tr>
	<tr>
		<td>5</td>
	</tr>
	<tr>
		<td>0</td>
	</tr>
	<tr>
		<td>41</td>
	</tr>
	<tr>
		<td>45</td>
	</tr>
	<tr>
		<td>47</td>
	</tr>
	<tr>
		<td>51</td>
	</tr>
	<tr>
		<td>52</td>
	</tr>
	<tr>
		<td>栈顶</td>
	</tr>
</table>

- 回收51、52，超级块栈满，分出一个空闲盘块将超级快内容复制到该空闲盘块中

- 下一个需要分配的盘块是53，用53指向空闲盘块，从53开始，压入超级块的栈中

<table style="border-collapse: collapse;">
	<tr>
		<th>空闲盘块号栈</th>
		<th>53号盘块中粗放囊的空闲盘块号</th>
	</tr>
	<tr>
		<td>栈底</td>
		<td>栈底</td>
	</tr>
	<tr>
		<td>53</td>
		<td>5</td>
	</tr>
	<tr>
		<td>54</td>
		<td>0</td>
	</tr>
	<tr>
		<td>55</td>
		<td>41</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>45</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>47</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>51</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>52</td>
	</tr>
	<tr>
		<td>▢</td>
		<td>栈顶</td>
	</tr>
</table>










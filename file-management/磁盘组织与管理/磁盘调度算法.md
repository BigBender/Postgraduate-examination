## 磁盘调度

- 硬件解决

- 好的调度算法

- 缓冲区

- 来自不同进程的磁盘I/O请求构成一个随机分布的请求队列

- 磁盘I/O调度算法的主要目标就是减少**请求队列对应的平均柱面定位时间**（寻道时间）

## 一次磁盘读写操作的时间

### 寻道时间Ts

- 活动头磁盘在读写信息前，将磁头**移动到指定磁道所需要的时间**

- 这个时间除跨越n条磁道的时间外，还包括启动磁臂的时间s， Ts = m*n + s

- m是跨越一条磁道的时间，与磁盘驱动器速度有关，约为0.2ms，磁臂启动时间约为2ms

### 延迟时间Tr

- 磁头**定位**到某一磁道的扇区所需的时间

- 设磁盘的旋转速度为r，则 Tr = 1/2r

- 对于硬盘、典型的旋转速度为 5400r/m，相当于一周 11.1ms，Tr=1/2r=5.55ms

- 对于软盘，旋转速度在 300\~600r/m之间，则Tr为50~100ms

### 传输时间Tt

- 从磁盘读出或向磁盘写入数据所经历的时间，取决于每次读/写字节数b和磁盘旋转速度

- Tt = b/rN，r为磁盘每秒钟的转数，N为一个磁道上的字节数

- 延迟时间和传输时间斗鱼磁盘旋转速度相关，且为**线性相关**

### 总平均存取时间Ts

- Ta = Ts + Tr + Tr = Ts + 1/2r + b/rN

### 读写操作时间相关计算

- 磁盘有1000个柱面(0~999)，设磁头当前位置是756，请求序列 811， 348， 153， 968， 407， 500

- 磁头向大的方向移动，CSCAN算法完成请求的磁道序列，计算总磁道数

- 756->811->968->153->348->407->500，总的磁道数：1374

- 设某单位面磁盘转速为每分钟12000转，每个磁道有100个扇区，相邻磁道间的平均移动时间为1ms

- 且对请求队列中的每个磁道需读取1个随机分布的扇区，计算完成这些磁盘请求的寻道时间

#### 计算寻道时间

- 1374*1ms=1.374s

- 计算完成这些磁盘请求的访问时间

#### 计算延迟时间

- 一分钟12000转，每秒200转，每转需要1/200=5ms

- 一共有100个扇区，读取每个扇区需要 0.05ms，一共需要 5ms

- 读取平均分配的扇区，平均延迟为每个扇区的一半 2.5ms 

- 延迟时间 6\*2.5=15ms，传输时间 6\*0.05=0.3ms

- 磁盘请求访问的总时间为：15.3+1374=1389ms

## 磁盘调度算法

### 先来先服务算法FCFS

- 根据进程请求访问磁盘的先后顺序进行调度

- 例如，磁盘请求队列中的请求顺序分别为 55、58、39、18、90、160、150、38、184

- 磁头初始位置是100磁道

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/FCFS.png)

磁头共移动了498个磁道，平均寻找长度=498/9=55.3

### 最短寻找时间优先

- 优先选择与当前磁头所在磁道距离最近的磁道调度处理，以使每次寻找时间最短

- 容易产生**饥饿**现象

- 例如，磁盘请求队列中的请求顺序分别为 55、58、39、18、90、160、150、38、184

- 磁头初始位置是100磁道

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/SSTF.png)

- 磁头共移动了248个磁道，平均寻找长度=248/9=27.5

### 扫描(SCAN)算法(电梯调度)(南理工默认SCAN是LOOK算法)

- SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象

- 例如，磁盘请求队列中的请求顺序分别为 55、58、39、18、90、160、150、38、184

- 磁头初始位置是100磁道，向磁道号增大的方向移动

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/SCAN.png)

- 磁头共移动了282个磁道，平均寻找长度=282/9=31.33

### 循环扫描(Circular SCAN, C-SCAN)算法

- 在SCAN基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始段而不服务任何请求

- 例如，磁盘请求队列中的请求顺序分别为 55、58、39、18、90、160、150、38、184

- 磁头初始位置是100磁道，向磁道号增大的方向移动

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/C-SCAN.png)

#### N-Step-SCAN算法

- 把磁盘I/O请求队列分成长度为N的段，每次使用扫描算法处理这N个请求

- 将请求的任务分成长度为N的若干个队列，**队列间的调度采用FCFS方式**，队列**内部的请求以SCAN方式调度**

- 该算法的目标是**解决磁臂粘着**问题

- 当N值很大时，该算法接近于SCAN;而N=1时该算法变为FCFS

#### FSCAN调度算法

- 将N-Step-SCAN算法中的队列数目定为2

- 把磁盘I/O请求**分成两个队列**，交替使用扫描算法处理一个队列，新生成的磁盘I/O请求放入另一队列中

- 该算法的目标与N步扫描算法一致**解决磁臂粘着**问题

### LOOK和C-LOOK

在 SCAN 和 C-SCAN 基础上改进

磁头移动只需要**达到最远端的一个请求即可返回**，不需要到达磁盘端点

例如，磁盘请求队列中的请求顺序分别为 55、58、39、18、90、160、150、38、184

磁头初始位置是100磁道，向磁道号增大的方向移动

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/LOOK&C-LOOK.png)

### 磁盘调度算法比较

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Comparison-of-disk-scheduling-algorithms.png)

### 减少延迟时间提高磁盘传输效率

- 对盘面扇区进行交替编号

- 对磁盘组中的不同盘面错位命名

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Disk-slice-group-sector-number.png)

- 读取连续编号扇区的一种方法

- 假设每条磁道被分为8个扇区，每个扇区存放一个记录，处理程序顺序处理这8个记录L1，L2，...，L8

- 每次请求从磁盘上读一个记录，然后对读出的记录花1ms时间进行处理，以后再读下一个记录进行处理

- 磁盘旋转一周花费16ms。若将8个记录在一条磁道上进行优化分布，则全部处理完这8个记录至少需要多少ms

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Disk-sector-alternate-numbering.png)

#### 典型例题

- 需要**考虑磁头当前移动方向**的调度算法是 SCAN(电梯调度)，C-SCAN，LOOK，C-LOOK






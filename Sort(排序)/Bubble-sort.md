## 冒泡排序

依次比较两个相邻的两个记录的关键字，若两个记录是反序的（即前一个记录的关键字大于后一个记录的关键字），进行交换，直到没有反序的记录为止。

### 一趟冒泡排序

对a[0]与a[1]的关键字比较大小，若反序，交换位置；然后比较a[1]与a[2]的关键字大小，若反序，交换位置。

以此类推，直到比较到最后两个关键字为止，称为一趟冒泡排序。

### 示例

对序列：**6，5，8，4，3，1** 进行一趟冒泡排序

![image](https://github.com/YC-L/hello-world/blob/master/imgs/Sort3.png)

* 图中灰色部分代表需要比较的元素

```cpp

int main()
{
	int a[10] = { 6,5,8,4,3,7 };

	int j, flag, temp, n = 6;
	for (int i = 0; i < n - 1; ++i){
		flag = 0;
		for (j = 0; j < n - i - 1; ++j){
			if (a[j] > a[j + 1]){
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				flag = 1;
			}
		}
		if (flag == 0){
			break;// 若该躺没有元素进行交换，终止排序。
		}			
	}
	j = 0;
	while (j < 6){
		printf("%d", a[j]);
		++j;
	}
	return 0;
}

```

### 时间复杂度分析

最坏情况，待排序列逆序，最内层基本操作的执行次数为n(n-1)/2，时间复杂度为O(n^2)

最好情况，待排序列有序，时间复杂度O(n)

平均情况下时间复杂度为O(n^2)

### 空间复杂度分析

额外辅助空间只有一个temp，空间复杂度为O(1)
## 页面置换算法

### OPT算法(看访问时间)

- 正向扫描过程，淘汰最后一个出现的页面

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-OPT.png)

### FIFO算法(看进入内存的时间)

- 维护一个队列，先进先出

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-FIFO.png)

存在**Belady**异常，即物理块数增大而**故障不减反增**

优先淘汰**最早**进入内存的页面

### LRU算法(看访问时间)

- 逆向扫描过程中，淘汰最后一个出现的页面

- 需要对所有的页进行**排序**，**实现耗费高**

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-LRU.png)

### CLOCK算法

#### 简单CLOCK算法 NRU(最近未使用)(最多需要两轮)

- 给一个页面访问序列 **1，3，4，2，5，6，3，4，7**，为进程分配5个页框 

- **第一次发生缺页**，维护一个循环队列

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-1.png)

- 第一轮扫描，把所有访问位置为0

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-2.png)

- 第二轮扫描，淘汰第一个访问位是0的页面，队列的指针指向该页面

- 将新的页换入淘汰位置，并置访问位为1，然后将队列的指针指向下一个页

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-3.png)

- 后续访问页面过程中，如果**不缺页**，访问位置为1

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-4.png)

- 后续访问过程中，如果**缺页**，扫描队列，淘汰第一个访问位为0的页面，队列的指针指向该页面

- 将新的页换入淘汰位置，并置访问位为1，然后将队列的指针指向下一个页

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-5.png)

- **不发生缺页**时，将扫描过的帧的使用位置为1

- 重复以上步骤

#### 改进型CLOCK算法

- 目的是**优先淘汰没有修改过**的页面

- 在NRU基础上，增加一个**修改位**，(访问位,修改位)，(u, m)

- 在发生缺页时，维护一个循环队列

- 第一轮扫描，从当前位置扫描到第一个(0, 0)的帧用于替换，不修改任何标志位

- 若第一轮扫描失败，第二轮扫描查找第一个(0, 1)的帧替换，将所有扫描过的帧访问位设为(0, *)

- 若第二轮扫描失败，第三轮扫描查找第一个(0, 0)的帧替换，不修改任何标志位

- 若第三轮扫描失败，第四轮扫描查找第一个(0, 1)的帧替换

- 淘汰一个页面**最多**进行**四轮扫描**

### 典型例题

- 某计算机的逻辑地址空间和物理地址空间都是64KB，按字节编址。

- 若某进程最多需要6页数据存储空间，每页大小为1KB，操作系统采用**固定分配局部淘汰**为策略为此进程分配4个页帧

<table style="border-collapse: collapse;">
	<tr>
		<th>页号</th>
		<th>页框</th>
		<th>装入时刻</th>
		<th>有效位</th>
	</tr>
	<tr>
		<td>0</td>
		<td>7</td>
		<td>130</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>4</td>
		<td>230</td>
		<td>1</td>
	</tr>
	<tr>
		<td>2</td>
		<td>2</td>
		<td>200</td>
		<td>1</td>
	</tr>
	<tr>
		<td>3</td>
		<td>9</td>
		<td>160</td>
		<td>1</td>
	</tr>
</table>

- 当该进程执行到时刻260时，需要访问逻辑地址17CAH的数据，该逻辑地址对应的页号是多少

- 逻辑地址化为二进制 0001 0111 1100 1010，每页大小1KB=2^10，低10位是页内偏移

- 页号为 0001 01，化为十进制 5

- 若采用FIFO置换算法，该逻辑地址对应的物理地址是多少

- 根据装入时刻，0->3->2->1，淘汰0号页，5号页面使用7号页框，逻辑地址页号部分变为 0001 11(10进制的7)

- 5号的逻辑地址变为 0001 1111 1100 1010(H)=1FCAH 

- 若采用Clock算法，该逻辑地址对应的物理地址是多少

- 0->3->2->1，循环队列从当前页**1**开始，经过两轮扫描结束，淘汰页面1

- 将第五个页放入淘汰页面对应的位置，页框号为4，对应的逻辑地址为 0001 0011 1100 1010(H)=13CAH

#### 典型例题

- 系统采用页式虚拟存储管理，采用固定分配局部置换策略，某进程有6个逻辑页，系统为其分配了4个物理页框

- 某时刻该进程的页表如表所示(单位:ns)

- 进程执行到290ns时，产生缺页中断

<table style="border-collapse: collapse;">
	<tr>
		<th>页号</th>
		<th>块号</th>
		<th>装入时间</th>
		<th>上次访问时间</th>
		<th>访问位</th>
		<th>修改位</th>
	</tr>
	<tr>
		<td>0</td>
		<td>6</td>
		<td>100</td>
		<td>260</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>1</td>
		<td>8</td>
		<td>260</td>
		<td>279</td>
		<td>1</td>
		<td>1</td>
	</tr>
	<tr>
		<td>2</td>
		<td>9</td>
		<td>220</td>
		<td>272</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>3</td>
		<td>7</td>
		<td>120</td>
		<td>250</td>
		<td>1</td>
		<td>1</td>
	</tr>
</table>

- 采用LRU算法，按照访问时间排序，3->0->2->1，逆向扫描，最后一次出现的是3号页面

- 采用FIFO算法，按照装入时间排序，0->3->2->1，先淘汰0号页面

- 采用CLOCK算法(指针在一号页)，第一遍扫描，没有0访问位，将所有访问位置为0

- 第二遍扫描，1号页为扫描过程中出现的第一个0访问位，淘汰1号页

- 采用改进型CLOCK算法(指针在三号页)，第一遍扫描，没有(0, 0)，第二遍扫描，没有(0, 1)，将扫描过的访问位置为1

- 第三遍扫描，0号页为扫描过程中的第一个(0, 0)，所以淘汰0号页面




















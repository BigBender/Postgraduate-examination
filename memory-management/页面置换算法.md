## 页面置换算法

### OPT算法(看访问时间)

- 正向扫描过程，淘汰最后一个出现的页面

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-OPT.png)

### FIFO算法(看进入内存的时间)

- 维护一个队列，先进先出

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-FIFO.png)

存在**Belady**异常，即物理块数增大而**故障不减反增**

优先淘汰**最早**进入内存的页面

### LRU算法(看访问时间)

- 逆向扫描过程中，淘汰最后一个出现的页面

- 需要对所有的页进行**排序**，**实现耗费高**

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-LRU.png)

### CLOCK算法(如果不规定指针位置，从装入时间最晚的页面开始扫面)

#### 简单CLOCK算法 NRU(最近未使用)(最多需要两轮)

- 给一个页面访问序列 **1，3，4，2，5，6，3，4，7**，为进程分配5个页框 

- **第一次发生缺页**，维护一个循环队列

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-1.png)

- 第一轮扫描，每遇到访问位为1的页面将访问位置为0，选择访问位为0的页面替换

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-2.png)

- 第二轮扫描，淘汰第一个访问位是0的页面，队列的指针指向该页面

- 将新的页换入淘汰位置，并置访问位为1，然后将队列的指针指向下一个页

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-3.png)

- 后续访问页面过程中，如果**不缺页**，访问位置为1

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-4.png)

- 后续访问过程中，如果**缺页**，扫描队列，将访问位为1的页面置为0，淘汰第一个访问位为0的页面，队列的指针指向该页面

- 将新的页换入淘汰位置，并置访问位为1，然后将队列的指针指向下一个页

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Memory-NRU-5.png)

- **不发生缺页**时，将扫描过的帧的使用位置为1

- 重复以上步骤

#### 改进型CLOCK算法

- 目的是**优先淘汰没有修改过**的页面

- 在NRU基础上，增加一个**修改位**，(访问位,修改位)，(u, m)

- 在发生缺页时，维护一个循环队列

- 第一轮扫描，从当前位置扫描到第一个(0, 0)的帧用于替换，不修改任何标志位

- 若第一轮扫描失败，第二轮扫描查找第一个(0, 1)的帧替换，将所有扫描过的帧访问位设为(0, *)

- 若第二轮扫描失败，第三轮扫描查找第一个(0, 0)的帧替换，不修改任何标志位

- 若第三轮扫描失败，第四轮扫描查找第一个(0, 1)的帧替换

- 淘汰一个页面**最多**进行**四轮扫描**

### 典型例题

- 某计算机的逻辑地址空间和物理地址空间都是64KB，按字节编址。

- 若某进程最多需要6页数据存储空间，每页大小为1KB，操作系统采用**固定分配局部淘汰**为策略为此进程分配4个页帧

<table style="border-collapse: collapse;">
	<tr>
		<th>页号</th>
		<th>页框</th>
		<th>装入时刻</th>
		<th>有效位</th>
	</tr>
	<tr>
		<td>0</td>
		<td>7</td>
		<td>130</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>4</td>
		<td>230</td>
		<td>1</td>
	</tr>
	<tr>
		<td>2</td>
		<td>2</td>
		<td>200</td>
		<td>1</td>
	</tr>
	<tr>
		<td>3</td>
		<td>9</td>
		<td>160</td>
		<td>1</td>
	</tr>
</table>

- 当该进程执行到时刻260时，需要访问逻辑地址17CAH的数据，该逻辑地址对应的页号是多少

- 逻辑地址化为二进制 0001 0111 1100 1010，每页大小1KB=2^10，低10位是页内偏移

- 页号为 0001 01，化为十进制 5

- 若采用FIFO置换算法，该逻辑地址对应的物理地址是多少

- 根据装入时刻，0->3->2->1，淘汰0号页，5号页面使用7号页框，逻辑地址页号部分变为 0001 11(10进制的7)

- 5号的逻辑地址变为 0001 1111 1100 1010(H)=1FCAH 

- 若采用Clock算法，该逻辑地址对应的物理地址是多少

- 0->3->2->1，循环队列从当前页**1**开始，经过两轮扫描结束，淘汰页面1

- 将第五个页放入淘汰页面对应的位置，页框号为4，对应的逻辑地址为 0001 0011 1100 1010(H)=13CAH

#### 典型例题

- 系统采用页式虚拟存储管理，采用固定分配局部置换策略，某进程有6个逻辑页，系统为其分配了4个物理页框

- 某时刻该进程的页表如表所示(单位:ns)

- 进程执行到290ns时，产生缺页中断

<table style="border-collapse: collapse;">
	<tr>
		<th>页号</th>
		<th>块号</th>
		<th>装入时间</th>
		<th>上次访问时间</th>
		<th>访问位</th>
		<th>修改位</th>
	</tr>
	<tr>
		<td>0</td>
		<td>6</td>
		<td>100</td>
		<td>260</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>1</td>
		<td>8</td>
		<td>260</td>
		<td>279</td>
		<td>1</td>
		<td>1</td>
	</tr>
	<tr>
		<td>2</td>
		<td>9</td>
		<td>220</td>
		<td>272</td>
		<td>1</td>
		<td>0</td>
	</tr>
	<tr>
		<td>3</td>
		<td>7</td>
		<td>120</td>
		<td>250</td>
		<td>1</td>
		<td>1</td>
	</tr>
</table>

- 采用LRU算法，按照访问时间排序，3->0->2->1，逆向扫描，最后一次出现的是3号页面

- 采用FIFO算法，按照装入时间排序，0->3->2->1，先淘汰0号页面

- 采用CLOCK算法(指针在一号页)，第一遍扫描，没有0访问位，将所有访问位置为0

- 第二遍扫描，1号页为扫描过程中出现的第一个0访问位，淘汰1号页

- 采用改进型CLOCK算法(指针在三号页)，第一遍扫描，没有(0, 0)，第二遍扫描，没有(0, 1)，将扫描过的访问位置为0

- 第三遍扫描，0号页为扫描过程中的第一个(0, 0)，所以淘汰0号页面

#### 典型例题(综合TLB快表，访存时间)

<table style="border-collapse: collapse;">
	<tr>
		<th>页号</th>
		<th>块号</th>
		<th>有效位</th>
	</tr>
	<tr>
		<td>0</td>
		<td>101H</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>--</td>
		<td>0</td>
	</tr>
	<tr>
		<td>2</td>
		<td>254H</td>
		<td>1</td>
	</tr>
</table>

- 页表内容如上，页面大小4KB，一次内存的访问时间是100ns，一次快表(TLB)的访问时间是10ns

- 处理一次缺页的平均时间10^8ns，**进程的驻留集大小固定为2**，采用**LRU**和局部淘汰策略

- 假设TLB初始为空，地址转换时先访问TLB，若TLB未命中，再访问页表，有效位为0的表示页面不在内存

- 产生缺页中断，缺页中断处理后，返回到产生缺页中断的指令处重新执行

- 设有虚地址访问序列 2362H，1565H，25A5

- 依次访问上述三个虚拟地址，各需多少时间

- 一页大小 4KB=2^12B，页内偏移占12位

- 2362H = 0010 0011 0110 0010，1565H = 0001 0101 0110 0101，25A5H = 0010 0101 1010 0101 

- 三个地址的页号，分别为 2，1，2

- 2362H，先访快表，10ns，不存在，访存100ns，合成物理地址后访存，100ns，10+100+100=210ns

- 1565H，先访快表，10ns，不存在，访存100ns，缺页处理10^8ns，访快表，10ns，合成物理地址后访存，100ns，10+100+10^8+10+100 ns

- 25A5H，先访快表，10ns，存在，合成物理地址后访存，100ns，10+100=110ns

- 基于上述访问序列，虚地址1565H的物理地址是多少

- 初始状态，是0号页和2号页在驻留集中，驻留集容量只有2，1号缺页，LRU，逆向扫描，淘汰0号页

- 1号页装入淘汰的位置，对应的物理块号为101H，加上页内偏移，101565H

#### 综合快表，访问时间

- 页面大小1KB，，采用固定分配局部置换策略。访存一次时间为50ns，访快表一次时间为10ns

- 处理一次缺页的平均时间为50ms(包括更新TLB和页表的时间)

- 设快表初始为空，快表为命中时，忽略快表的更新时间。系统为某进程分配3个页框如下

<table style="border-collapse: collapse;">
	<tr>
		<th>页号</th>
		<th>页框号</th>
		<th>访问位</th>
	</tr>
	<tr>
		<td>0</td>
		<td>6</td>
		<td>1</td>
	</tr>
	<tr>
		<td>1</td>
		<td>7</td>
		<td>0</td>
	</tr>
	<tr>
		<td>2</td>
		<td>4</td>
		<td>0</td>
	</tr>
</table>

- 设该进程有逻辑地址访问序列 256H，D65H，AB7H，456H，6B7H，若采用CLOCK置换算法

- 查询被置换页的指针初始在0号页，查找顺序由上至下

- 遵循上述地址访问序列，访问虚地址256H，D65H，6B7H

- 256H = 0010 0101 0110，0号页在内存中，不发生缺页，访快表，访存(合成地址)，访存(访问页面)

- 10 + 50 + 50 = 110ns

- D65H = 1101 0110 0101，3号页不在内存中，访快表，访存(合成地址)，缺页处理，访快表，访存(访问页面)

- (10 + 50 + 5*10^7 + 10 + 50) ns

- 淘汰1号页，将3号页放入1号页的位置，指针指向3号页，对应页框7

- AB7H = 1010 1100 0111，2号页在内存中，访快表一次，访存(合成地址)，访存(访问页面)

- 10 + 50 + 50 = 110ns

- 456H = 0100 0101 0110，1号页不在内存中，访快表一次，访存(合成地址)，缺页处理，访快表，访存(访问页面)

- (10 + 50 + 5*10^7 + 10 + 50) ns

- 淘汰2号页，将1号页放入2号页的位置，指针指向1号页，对应页框4

- 6B7H = 0110 1011 0111，1号页在内存中，访快表，访存(访问页面)

- 10 + 50 = 60 ns

- 对应页框4

- 遵循题目的地址访问顺序，写出逻辑地址 256H，D65H，456H对应的物理地址

- 256H对应6号页框 1 1010 0101 0110 = 1A56H

- 访问D65H，淘汰掉1号页面，将3号页放入相应位置，对应7号页框 1 1101 0110 0101 = 1D65H

- 访问456H，淘汰掉2号页面，将1号页放入相应位置，对应4号页框 1 0000 0101 0110 = 1056H

#### CPU利用率，磁盘利用率

- CPU利用率13%，硬盘利用率97%

- 系统出现"抖动"线性，这时若再增加并发进程数反而会恶化系统性能

- CPU利用率87%，硬盘利用率3%，系统正常

- CPU利用率13%，硬盘利用率3%，CPU没有充分利用，因该增加并发进程数量

#### 缺页中断率

- 有一个可用的空页或被置换的页未被修改，则它处理一个缺页中断需要8ms

- 若被置换的页已被修改，则处理一缺页中断因增加写回外存的时间而需要20ms，内存的存取时间为1us

- 假定70%被置换的页被修改过，为保证有效存取时间不超过2us，可接受的最大缺页中断率是多少

- 未缺页时，直接访问内存，用时1us；当缺页时，如果未修改，则用时 8ms+1us

- 当缺页时，而且修改了，则用时 20ms + 1us

- 设最大缺页中断率为p，则有 (1-p)\*1us + (1-0.7)\*p(8ms+1us) + (1-0.7)\*p(20ms+1us)

#### 计算页表级数以及页面平均访问时间

- 已知系统为32位实地址，采用48位虚拟地址，页面大小4KB，页表项大小为8B，每段最大为4GB

- 假设系统使用纯页式存储，则要采用多少级页表，页内偏移多少位

- 页面大小 4KB=2^12，页内偏移占12位，页号占 48-12=36位，一个页面可以装 2^12/2^3=2^9个页表项

- 2^9\*2^9\*2^9\*2^9=2^36，所以至少需要4级页表

- 假设系统采用一级页表，TLB命中率为98%，TLB访问时间10ms，内存访问时间100ns

- 假设当TLB访问失败时才开始访问内存，平均页面访问时间是多少

- 0.98(10 + 100) + 0.02(10 + 100 + 100) ns 

- 第二个 100ns，是在第一次访存合成物理地址之后再访存

- 如果是二级页表，页面平均访问时间是多少

- 0.98(10 + 100) + 0.02(10 + 100 + 100 + 100) ns

- 上题中，如果要满足访问时间小于120ns，那么命中率需要至少多少

- 设命中率为p p(10 + 100) + (1-p)(10 + 100 + 100 + 100)<120ns

- 若系统采用段页式存储，则用户最多可以有多少个段，段内采用几级页表

- 系统采用48位虚拟地址，每段最大为4GB，故段内偏移为32位，段号占48-32=16位，每个用户最多有2^16个段

- 段内采用页式地址，一页 4KB=2^12，页内偏移占12位，页号占 32-12=20位

- 一个页面可以2^12/2^3=2^9个页表项，2^9\*2^9\*2^9>20，需要三级页表

#### 在给定驻留集大小情况下，在什么样的访问串情况下，FIFO与LRU替换算法一样

- 访问串中所有页面号都应不同

- 连续访问相同页面时不影响后面的替换选择

- 不连续的页面号均不相同

#### 代码运行顺序与内存中的存储方式相关造成的缺页情况 

- 某一矩阵 int A[100, 100]以**行优先**进行存储

- 计算机采用虚拟存储系统，物理内存共有三页，其中一页用来存放程序，其余两页用于存放数据

- 假设程序已在内存中占一页，其余两页空闲，若每页可存放200个整数，程序1、程序2执行过程各发生多少次缺页

- 若每页只能存放100个整数呢

```cpp

for(int i = 0; i<100; i++){
	for(int j = 0; j < 100; j++){
		A[i, j]=0;
	}
}

```

```cpp

for(int j = 0; j<100; j++){
	for(int i = 0; i < 100; i++){
		A[i, j]=0;
	}
}

```

- 程序1按行优先的顺序访问数组元素，与数组在内存中存放的顺序一致，每个内存页面可存放200个数组元素

- 程序1每访问两行数据元素产生一次缺页中断，程序1的执行过程会发生50次缺页

- 程序2按列优先的顺序访问数组元素，由于每个内存页面存放两行数据元素

- 程序2每访问两个数组元素就产生一次缺页中断，整个执行过程发生5000次缺页

- **缺页次数**与内存中**数据存放方式**以及**程序执行的顺序**有很大关系

- 同时说明，当**缺页中断次数不多**时，**减小页面大小影响并不大**，但**缺页中断次数很多**时，**减小页面大小会带来很严重的问题**

#### 虚拟地址空间的划分

- 64位的计算机体系结构

- 假设页面大小是4KB，每个页表项的长度4B，采用三级页表结构，每一级页表结构当中的每个页表都必须正好放在一个物理页面中

- 如何实现地址映射，如何划分虚拟地址

- 页面大小 4KB=2^12B，一个页面可以存放 2^12/2^2=2^10 个页表项，采用三级页表，2^30，占30位

- 虚拟地址空间的划分 10(一级索引) 10(二级索引) 10(三级索引) 12

#### 给定虚拟地址空间的划分求页大小，页框大小

- 页目录号10位，页表索引10，页内偏移量12

- 页 2^12B=4KB，页框也是 4KB

- 进程虚拟地址空间大小是多少页 虚拟地址空间一共32位，2^32B，一页12位，2^12B，所以虚拟地址空间2^20页

- 假定页目录项和页表项均占4字节，则进程的页目录和页表共占多少页

- 2^10个页目录，页表2^20，一页2^12B，2^10\*4/2^12 + 2^20\*4/2^12 = 1025

- 若某指令周期内访问的虚拟地址 0100 0000H 和 0111 2048H，则进行地址转换时共访问多少个二级页表

- 0000 0001 0000 0000 0000 0000 0000 0000

- 0000 0001 0001 0001 0010 0000 0100 1000

- 最高10位的值都是4，访问同一个二级页表






























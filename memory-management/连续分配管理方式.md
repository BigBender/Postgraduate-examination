## 连续分配管理方式

- 为一个用户程序分配一个连续的内存空间

### 单一连续分配

- 内存分为**系统区和用户区**，

- 系统区提供给操作系统使用，通常在低地址部分

- 用户区给用户提供的、除系统区之外的内存空间

- 无需内存保护，永远只有一道程序，不会因为访问越界而干扰其他程序

- 简单，**无外部碎片**，可采用覆盖技术，缺点是只能用于单用户、单任务，**有内部碎片**，存储器利用率极低

#### 外部碎片

- 没有被分配出去的内存，由于**太小了**无法分配给**申请内存**空间的新进程的**空闲区域**

#### 内部碎片

- 就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；

### 固定分区分配

- 最简单的一种**多道程序**存储管理方式， 

- 将用户内存空间**划分为若干个固定大小的区域**

- 当有**空闲分区**，可以从**外存的后备作业队列中**，**选择适当大小**的作业装入该分区，如此循环

- 每个分区**只装一道作业**，有空闲分区时，从外存的后备作业队列中选择适当大小的作业装入该分区

#### 两种不同的划分方式

- 分区大小**相等**: 用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性

- 分区大小**不等**: 划分为含有**多个较小**的分区、**适量的中等**分区及**少量的大**分区

- 为了便于内存分配，将分区按大小排队，建立一张分区说明表，用户程序**检索**该表装入，以找到合适的分区给予分配并将其状态置为"已分配"；**未找到**合适分区则**拒绝为该用户程序分配内存**

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Fixed-partition.png)

#### 划分方式存在的问题：

- 程序可能太大，装不进任何一个分区，必须用覆盖技术来使用内存空间；

- 主存利用率低，当程序小于固定分区大小，**占用完整内存分区空间**，分区内部浪费，称为**内部碎片**

- 固定分区是可用于多道程序设计最简单的存储分配，**无外部碎片**，但**不能实现多进程共享一个主存区**，所以存储空间利用率低

### 动态分区分配

- 动态分区又称**可变分区分配**，动态划分内存的分区方法

- 不预先将内存划分，而是在进程装入内存时，根据**进程大小动态建立分区**，使分区大小适合进程需要

- 系统中分区大小和数目可变

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Dynamic-partition.png)

- 动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块

- 随着时间推移，内存利用率随之下降，这些小内存块，称为**外部碎片**，在所有分区外的存储空间会变成越来越多碎片

- 与固定分区中的**内部碎片相对**

- 可以通过**紧凑**技术来实现，操作系统不断对进程进行移动和整理，这需要**动态重定位寄存器**的支持，相对费时

- 紧凑的过程类似于磁盘整理程序 

#### 动态分区分配策略

- 首次适应，**地址递增**，简单而且快，会使低地址产生很多小的空闲分区

- 最佳适应，**容量递增**，通常性能很差，产生很多**外部碎片**

- 最坏适应，**容量递减**，很快导致没有可用的大的内存块，性能也很差

- 邻近适应，又称**循环首次适应**，从**上次查找结束的位置继续查找**

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Comparison-of-three-memory-partition-management-methods.png)

- 以上三种内存分区管理方法有一共同特点，用户进程在主存中都是连续存放的

#### 典型例题

- 基于动态分区存储管理的计算机，主存容量为55MB，采用最佳适配算法

- 分配和释放顺序为，分配15MB，分配30MB，释放15MB，分配8MB，分配6MB，此时主存中最大空闲分区的大小

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Best-fit.png)













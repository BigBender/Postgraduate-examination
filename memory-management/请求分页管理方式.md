## 请求分页管理方式

### 页表机制

![请求分页系统中页表项](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%A1%B5%E8%A1%A8%E9%A1%B9.png "请求分页系统中页表项")

- **状态位(合法位)**P：用于指示该页**是否已调入内存**，供程序访问参考，

- **访问位**A：用于记录本页在一段时间内**被访问的次数**

- **修改位**M：标识该页在调入内存后**是否被修改过**

- **外存地址**：用于指出该页在外存上的地址，通常是物理块号

### 缺页中断机构

- 每当所访问的**页面不在内存中**，产生一个**缺页中断**，请求操作系统将所缺的页调入内存

- 如果内存中没有空闲块，需要淘汰一个页面

- 进程在执行时发生**缺页中断**，经操作系统处理后，应让其执行被**中断那一条指令**

- 在缺页处理过程中，操作系统执行的操作可能是 **修改页表**、**分配页框**、**磁盘IO**(内存中没有页面，从外存调入)

- 页表项中的合法位，决定是否会发生页故障

### 地址变换机构

- 先**检索快表**，若找到要访问的页，**修改页表项中的访问位**

- 若未找到，到**内存中**查找页表，**对比页表项中的状态位P**，=

- 未调入产生缺页中断，请求从外存把该页调入内存

- 能**加快虚实地址转换**的是，增大快表(TLB)容量，让页表常驻内存

#### 有效访问时间

- 某分页式虚拟存储系统，用于页面交换的磁盘的平均平均访问及传输时间20ms

- 页表保存在主存，访问时间为1us，即每引用一次指令或数据，需要访问两次内存

- 为改善性能可以增设一个关联寄存器，如果页表项在关联寄存器里，则只要访问依次内存就可以

- 假设80%的访问页表项在关联寄存器，剩下的20%中，10%的访问(总数的2%)会产生缺页，请计算有效访问时间

- 关联寄存器中，80%是1us，剩下的20%中，18%不缺页，需要先查快表再查内存，访存两次，1+1=2us

- 最后的2%，访存两次，2us，缺页中断，访盘调页，20ms，最后访存一次 1us

#### 缺页故障的上限和下限

- 在页式虚存管理系统中，假定驻留集为m个页帧(初始所有页帧均为空)，在长为p的引用串中具有n个不同页号(n>m)，对于FIFO、LRU两种页面置换算法，给出页故障数的上限和下限

- 驻留集 < 页号，这两种算法的出页故障上限为p，下限为n













## 非连续分配管理方式

非连续分配允许一个程序分散地装入到不相邻地内存分区中、


### 基本分页存储管理方式

分页管理不会产生外部碎片，进程只会在为最后一个不完整块，申请一个主存块空间时，才产生主存碎片

每个进程平均只产生半个块大小的内部碎片(页内碎片)

- 页： 进程中的块
- 页框： 内存中的块(页帧)
- 同样的单位，外存中也称为块
- 进程执行时，申请主存空间，为每个页面分配主存中的可用页框，产生了页和页框的一一对应

![地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "地址结构")

页表，**由页表项组成**，系统为每个进程建立一个页表，记录页面在内存中对应的物理块号

**页表项与地址的区别**

页表项与地址第一部分都是页号，页表项的第二部分是物理内存中的块号，地址的第二部分是页内偏移；页表项的第二部分和地址的第二部分共同组成物理地址

基本地址变换机构，由硬件完成

**页式管理中地址空间是一维的**

缺点

- 地址转换若不够快，导致访存速度降低
- 页表若太大，导致内存利用率降低

**具有快表的地址变换机构**

1. 给出逻辑地址后，先查快表，找不到，再查主存
2. 找到以后缓存再快表中

**快表基于局部性原理**

**两级页表**

举个例子，32位逻辑地址，页面大小4KB，页表项大小4B，若要实现进程对全部逻辑地址空间映射，

每个进程需要 2^20 各页表项，4KB = 2^12B，占12位(页内偏移)，32-12=20，即页号占有的位数

每个进程页表这一项，需要 2^20 * 4 = 4MB 主存空间，不切实际，延伸为二级页表，将20为页号，划分为两部分

![两级页表地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "两级页表地址结构")


### 基本分段存储管理方式

1.分段，段式管理方式按照用户进程中的自然段划分逻辑空间，**对用户透明**，每个段分配一段连续的地址空间(**段内要求连续，段间不要求连续**)，整个作业的地址空间是**二维**的

![分段逻辑地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/分段逻辑地址结构.png "分段逻辑地址结构")

2.段表

![段表项](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%AE%B5%E8%A1%A8%E9%A1%B9.png "段表项")

3.地址变换机构，段表寄存器

4.段的共享与保护

段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的，当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为**纯代码或可重入代码**

分段管理的保护方法有两种：
1. 存取控制保护
2. 地址越界保护

段式管理不能给出一个整数确定对应的物理地址，段号和段内偏移要显式给出，**分段管理的地址空间是二维的**

### 段页式管理方式

先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址

进行一次访问，需要三次访问主存，段页式管理的地址空间是二维的









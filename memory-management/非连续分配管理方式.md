## 非连续分配管理方式

- 非连续分配允许一个程序**分散地**装入到**不相邻**的内存分区中

- 需要额外的空间去存储它们的索引，**非连续分配方式**的**存储密度低**于**连续存储方式**

- 根据**分区的大小是否固定**分为分页存储管理方式和分段存储管理方式

- 分页存储管理方式中，根据运行作业时**是否把作业的所有页面都装入内存才能运行**分为**基本分页**存储管理和**请求分页**存储管理

### 基本分页存储管理方式

- 分页管理**不会产生外部碎片**，

- 块的大小相对分区**小很多**，进程也按块进行划分，进程运行时**按块申请主存可用空间**并执行

- 进程只会在为**最后一个不完整块**，申请一个主存块空间时，才产生**主存碎片**(内部碎片)

- 每个进程平均只产生**半个块大小**的内部碎片(页内碎片)

#### 分页存储的几个基本概念

##### 页

- 页面和页面： 进程中的块(逻辑)

- 页框： **内存**中的块(**页帧**)(物理)，**外存**中直接称为**块**(Block)

- 进程执行时，申请**主存空间**，为每个**页面**分配主存中的**可用页框**，产生了页和页框的一一对应

- 如果页面太小，会使进程的页面数过多，页表过长，占用大量内存，增加硬件地址转换的开销，降低页面换入/换出效率

- 页面过大会使页内碎片增大，降低内存利用率，所以页面大小应当适中，考虑空间效率和时间效率的权衡

##### 地址结构

![地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "地址结构")

- 前一部分为页号P，后裔部分为页内偏移量W

- **地址结构决定**了虚拟内存的寻址空间有多大

##### 页表

- 页表，由**页表项**组成，系统为**每个进程**建立**一个页表**，记录**页面**在内存中对应的**物理块号**

- 页表项与地址都是由两部分构成

- 第一部分都是**页号**，但页表项的第二部分是**物理内存中的块号**，**地址**的第二部分是**页内偏移**

- 页表项的第二部分和地址的第二部分**共同组成物理地址**

- 页表的作用实现从页号到物理块号的地址映射

![页表](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/The-role-of-the-page-table.png)

- 页表的作用

- **页式**管理中**地址空间**是**一维**的

#### 基本地址变换机构

- 地址变换机构的任务是将逻辑地址转换为内存中物理地址，借助于页表实现

![页表](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Paging-storage-management-address-translation-mechanism.png)

- 分页存储管理地址变换结构

- 在系统中常常设置一个**页表寄存器(PTR)**，存放页表在**内存的始址F和页表长度M**

- 进程**未执行**时，页表的始址和长度存放在**PCB**(进程控制块)中，进程执行时，再将页表始址和长度存入页表寄存器

- 设页面大小为L，逻辑地址A到物理地址E的变换过程如下

- 计算页号P(P=A/L)和页内偏移量W(W=A%L)

- 比较**页号P和页表长度M(一共有多少页)，若P≥M**，则产生**越界中断**，否则继续执行

- 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度(页地址占的存储空间)，取出页表项内容b，即为物理块号

- 计算E=b*L + W，用得到的物理地址E去访问内存

#### 地址变换例题

- 页面大小L为1K字节，页号2对应的物理块为 b-8，计算逻辑地址A=2500的物理地址E

- 页号，P=2500/1K=2500/2^10=2，页内偏移，W=2500%1K=2500%2^10=452，页号2对应的物理块号为8

- E=8*1024 + 452=8644

- 页式管理只需要给出一个整数就能确定对应的物理地址

#### 页表项的作用

- 32位逻辑地址空间，字节为编址单位，一页4KB，地址空间内含有 2^32B/4KB=2^32/2^12=2^20=1M页

- 即需要 log2 1M = 20为才能保证表示范围能容纳所有页面

- 因为以字节作为编址单位，页表项的大小≥⌈20/8⌉=3B，为了保证页表项能够指向所有页面，页表项大小≥3B

#### 页式管理存在的问题

- 每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须**足够快**，**否则访存速度会降低**

- 每个进程引入了页表，用于存储映射机制，**页表不能太大**，否则内存利用率降低(内部碎片)

#### 具有快表的地址变换机构

- 若页表全部放在内存中，存取一个数据或一条指令至少要访**两次**内存

- 一次是访问页表，确定所存取的数据或指令的物理地址，第二次根据地址存取数据或指令

- 比通常执行指令的速度慢了一半

#### 引入快表(TLB)联想寄存器(硬件)

- 快表，TLB，用来存放当前访问的若干页表项，加速地址变换的过程

- 慢表，主存中的页表

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Address-conversion-mechanism-with-TLB.png)

- CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存(cache)寄存器，并将此页号与快表中的所有页号进行比较

- 若找到匹配的页号，说明所要访问的页表项在快表中，直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址

- 存取数据仅一次访存即可实现

- 若没有到匹配的页号，需要访问主存中的页表，读出页表项后，同时将其存入快表，以便后面可能再次访问

- 若快表已满，按照算法进行页面置换

- **有些处理机**设计为快表和慢表同时查找，若在快表中查找成功中值慢表查找

- 一般快表的命中率达到90%以上，分页带来的速度损失降低到10%一下，快表有效性基于**局部性原理**

#### 两级页表

- **为了查询方便，顶级页表最多只能有一个页面**

- 举个例子，32位逻辑地址，页面大小4KB，页表项大小4B，若要实现进程对全部逻辑地址空间映射，

- 每个进程需要 2^20 个页表项，4KB = 2^12B，占12位(页内偏移)，32-12=20，即页号占有的位数

- 每个进程页表这一项，需要 2^20 * 4 = 4MB 主存空间，不切实际，延伸为二级页表，将20位页号，划分为两部分

![两级页表地址空间](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "两级页表地址结构")
- 地址空间 

![两级页表结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Two-level-page-table-structure.png)
- 页表结构

![多级页表地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Multi-level-page-table-logical-address-space.png)
- 多级页表地址空间

#### 多级页表数的计算

- 多级页表的目的在于**建立索引**，不用浪费主存空间存储无用的页表项，不用盲目地顺序式查找页表项

#### 典型例题

- 32位系统地址空间，页的大小4KB，页表每个表项占用4B，采取几级页表

- 一页 2^12 即 页内偏移占12位，剩下 32-12=20 位表示页号，有 2^20 页

- 一页可以装 2^12/2^2=2^10 个页表项，容纳 2^20 个页面，需要两级 (2^10)^2

#### 典型例题

- 已知系统32位实地址，采用48位虚地址，页面大小为4KB，页表项大小为8B，假设系统使用纯页式存储

- 页面大小 1KB=2^12，页内偏移 12位，页号位数，48-12=36位，一个页面可以装 4KB/8B=2^12/2^3=2^9 个页表项

- 虚地址一共可以有2^36个页号，(2^9)^4=2^36，所以需要四级页表 

#### 分页存储方式

- 某系统主存在字节编址，内存采用分页管理机制，物理页框大小为4B，每个页表项占2B，进程P得逻辑地址空间为32B

- 进程P的PCB中存放的最外层页表所在的物理页框号为8

- 下面给出了进程P各级页表依次存放的物理页框号

<table style="border-collapse: collapse;">
	<tr>
		<th>8号页框存放的页框号</th>
		<th>35号页框存放的页框号</th>
		<th>30号页框存放的页框号</th>
		<th>21号页框存放的页框号</th>
		<th>16号页框存放的页框号</th>
		<th>13号页框存放的页框号</th>
		<th>24号页框存放的页框号</th>
	</tr>
	<tr>
		<td>35</td>
		<td>21</td>
		<td>13</td>
		<td>3</td>
		<td>2</td>
		<td>11</td>
		<td>9</td>		
	</tr>
	<tr>
		<td>30</td>
		<td>16</td>
		<td>24</td>
		<td>5</td>
		<td>7</td>
		<td>17</td>
		<td>44</td>
	</tr>
</table>

- 问需要几级页表

- 地址空间大小/页框大小 32B/4B=8 个页框，一个页框可以存放 4/2=2 个页框，2^3=8，需要3级页表

- 逻辑地址20对应的物理地址

- 32B=2^5B，逻辑地址占5位，3级页表，每级页表占1位(1个块中两个页表)

- 按照表格将3级页表拼起来(**从上向下升序**)

![分段逻辑地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Multi-level-page-table.png)

- 20 = 1 0100 ，页内偏移0，1级页号为1，对应30号页框，2级页号为0，对应13号页框，3级页号为1，对应17号页框

- 17与页内偏移0拼接，最后的物理地址 1000100 = 44H 

### 基本分段存储管理方式

- 分段管理方式地提出是考虑了用户和程序员，满足**方便编程**，**信息保护和共享**，**动态增长**及**动态链接**等

#### 分段

- 段式管理方式按照用户进程中的**自然段划分逻辑空间**，**对用户透明**

- 每个段分配一段连续的地址空间(**段内要求连续，段间不要求连续**)，整个作业的**地址空间**是**二维**的

![分段逻辑地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%88%86%E6%AE%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "分段逻辑地址结构")

- 执行中地进程可通过查找段表，找到每个段所对应地内存区，段表用于实现动逻辑段到物理内存区的映射

#### 段表

![段表项](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%AE%B5%E8%A1%A8%E9%A1%B9.png "段表项")
- 段表项

![段表项](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Use-segment-table-to-implement-address-mapping.png "段表项")
- 利用段表实现地址映射

#### 地址变换机构

![段表项](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Segmentation-system-address-translation-mechanism.png "段表项")

- 比较段号和段表长度M，若S≥M，则产生越界中断，否则继续执行

- 段表中短号S对应的段表项地址=段表起始地址F+短号S*段表项长度，取出该段表项前几位得到段长C

- 若段内偏移量≥C，产生越界中断，否则继续执行

- 取出段表项中该段的起始地址b，计算E=b+W，用得到的物理地址E去访问内存

#### 段的共享与保护

- 段的共享是通过两个作业的段表中**相应表项指向被共享的段的**同一个**物理副本**来实现的

- 当一个作业正从共享段中读取数据时，必须**防止另一个作业**修改此共享段中的数据

- **不能修改**的代码称为**纯代码**或**可重入代码**(它不属于临界资源)

- 这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享

#### 分段管理的保护方法有两种

- 存取控制保护

- **地址越界保护**，利用段表寄存器中的段表长度与逻辑地址中的短号比较，若段号大于段表长度则产生越界中断

- 再利用段表项中的段长和逻辑地址中的段内位移进行比较，**若段内位移大于段长**，也会产生越界中断

- **分页管理**中的地址越界保护只需要判断页号是否越界，**页内偏移不可能越界**

- 与页式管理不同，段式管理不能给出一个整数确定对应的物理地址，**每段长度不固定**，段号和段内偏移要**显式**给出(对用户和程序员是透明的)

- 分段管理的**地址空间**是**二维的**

### 段页式管理方式

- 页式存储管理**有效提高内存利用率**，分段存储管理能反映程序的逻辑结构**并利于段的共享**，结合起来是段页式

- 段页式系统中，作业的地址空间首先**分成若干个逻辑段**，每段有自己的页号，然后再将**每一段分成若干个大小固定的页**

- 对内存空间管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，内存分配以块为单位

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Segment-page-management.png "段表项")
- 段页式管理方式

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Segment-page-logical-address-space.png "段表项")
- 段页式逻辑地址空间

- 为了实现地址变换，系统为每个进程建立一张段表，每个分段有一张页表，段表表项中至少包括段号、页表长度和页表起始地址，页表表项至少包括页号和块号

- 系统中还应有一个**段表寄存器**，指出作业段表**起始地址**和**段表长度**

- 地址转换时，先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址

- 进行**一次访问**，需要**三次访问主存**

- 段页式管理的**地址空间**是**二维**的

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Segment-page-system-address-translation-mechanism.png)

#### 典型例题

- 段页式存储管理中，地址映射表是，每个进程一张段表，每个段一张页表

- 不会产生内部碎片的是分段式存储管理

- 采用分页或分段管理后，提供给用户的物理地址空间 不能确定，因为页表和段表的长度不确定

- 分页系统中的页面是**为操作系统所感知**的，内存分页管理是在内存、操作系统层面实现的

- 页式存储管理中，页表的始地址存放在 寄存器中 (PTR)

- 对重定位存储管理方式，应在整个系统中设置一个重定位寄存器

- 采用段式存储管理时，一个程序如何分段在**用户编程**时决定

- 分段存储管理方法有利于程序的动态链接

- 通过可重入程序是通过**减少对换数量**方法改善系统性能

- 可重入程序通过共享来使用同一块存储空间，或通过动态链接将所需程序段映射到相关进程中，减少了对程序段的调入调出，减少了对换数量

- 操作系统实现分区存储管理的代价最小(不需要特定的数据结构支持，不需要加硬件)

- 动态分区在系统运行过程中，在**作业装入时动态建立**

- 采用最佳适应算法，每次分配和回收内存后都对空闲分区链重新排序

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Best-fit-1.png)

- 回收起始地址为60K，大小为140KB的分区后，系统中空闲分区的数量、空闲分区链第一个分区的起始地址和大小

- 第1个分区和第3个分区合并，分区剩下3个，重排后，第一个分区是500K，大小80KB

- 虚拟存储器，作业不必全部装入，运行过程中也不必一直驻留在内存

- 非虚拟存储器，作业必须全部装入，运行过程中也必须一直驻留在内存

- 在页式存储管理方法，所划分的页**面大小必须相同**

- 对主存储器访问，是以字节或字为单位

- 在页式存储管理中，主存的分配是以物理块为单位进行分配

- 在段式分配中，CPU每次从内存取一次数据需要2次访问内存

- 在段页式分配中，CPU每次从内存中取一次数据需要3次访问内存

- 分页存储管理方式，要求**每个进程拥有一张页表**，且进程的页表**驻留**在内存中

- 段页式存储管理，分段方法分配和管理用户地址空间，分页方法管理物理存储空间

- **会产生内部碎片**，分页虚拟存储管理，段页式存储管理，固定式分区管理

- 只要是**固定**(分页，固定分区)的分配，就会产生**内部碎片**，(段式管理，每个段都不一样)其余产生外部碎片

- 现有一个容量为10GB的磁盘分区，磁盘空间以簇(Cluster)为单位进行分配，簇的大小为4KB

- 若采用位示图法管理该分区的空闲空间，即用一位(bit)表示一个簇是否被分配，则存放该位图所需簇为

- 10GB=10\*2^30B，4KB=2^12B，共需要10GB/4KB=10\*2^18位

- 共需要 10\*2^18/8=10/8\*2^18B, 共需要 10/8\*2^18B/4KB=10\*2^18/2^12=80簇

#### 动态分区和固定分区

- 动态分区解决了内部碎片，但还是有外部碎片；固定分区一定有内部碎片

- 分别给出了页式或段式两种地址变换示意图

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Address-transformation-diagram.png)

- 页或段的最大个数为 2^5=32，左图是段式管理，段始址

- 左图中段始址12+页内偏移586 远大于 其他段的段始址，分页存储管理，一页占11位，2^11B

- 右图中符合段式管理

- 计算两种变换所对应的物理地址，左图 12\*2^11+586，右图 4000+586

- 页式存储管理，允许用户编程空间位32个页面(每页1KB)，主存为16KB，用户程序有10页长

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/User-program-page-table.png)
- 某时刻该用户程序页表

- 0AC5H，1AC5H，3AC5H，存储管理系统将如何处理

- 页面大小1KB，页内偏移 2^11B，占逻辑地址空间11位，剩下5位是页号

- 0AC5H = 000 1010 1100 0101，页号为2，对应4号页框

- 物理地址 001 0010 1100 0101 = 12C5H

- 1AC5H = 001 1010 1100 0101，页号为6，对应程序表中没有，产生缺页中断

- 3AC5H = 011 1010 1100 0101，页号为14，用户程序只有10页产生越界中断

- 在某页式管理系统中，假定主存为64KB，分成16块，块号从0开始

- 设某进程有4页，其页号为 0,1,2,3 被分别装入主存的第9, 0, 1, 14块

- 该进程总长度是多大

- 一页的大小，64KB/16=4KB，4个页面，共有16KB

- 该进程每一页在主存中的起始地址

- 一页KB=2^12B，占12位，主存64KB=2^16，其中页内偏移占12位，剩下4位是页号

- 0号页 0100 0000 0000 0000，1号页 0000 0000 0000 0000

- 2号页 0001 0000 0000 0000，3号页 1110 0000 0000 0000

- 给出逻辑地址(0, 0), (1, 72), (2, 1023), (3, 99)，请计算出相应的内存地址

- (0, 0)=1001 0000 0000 0000B，(1, 72)=0000 0000 0100 1000

- (2, 1023)=0001 0001 1111 1111 (3, 99)=1110 0000 0110 0011

- 采用页式存储管理，页面大小为64B，假定一进程的代码段的长度为702B

- 给定一八进制的0105，0217，0567，01120，02500，问给定的地址能否转换

![image](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/Process-page-table&fast-table.png)

- 页面大小64B=2^6B，页内偏移地址空间的6位，代码段702B，有702/64=10页，共需要11个页面

- 0105O = 000 001 000 101，页号1，页帧F1，页内偏移5

- 0217O = 000 010 001 111，页号2，页帧F2，页内偏移15

- 0567O = 000 101 110 111，页号5，页帧F5

- 01120O = 000 001 001 010 000，页号9，页帧F9

- 02500O = 000 010 011 000 000，页号19，越界 

- 假设一个64MB内存容量的计算机，其操作系统采用页式存储管理(页面大小为4KB)，内存分配

- 采用位示图管理，问位示图将占用多大内存

- 一共有64MB/4KB=2^26/2^12=2^14(bit)，用位示图表示1位一个物理块(一个物理块8位)2^14/8=2^11=2KB










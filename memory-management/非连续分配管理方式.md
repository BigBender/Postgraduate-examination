## 非连续分配管理方式

非连续分配允许一个程序**分散地**装入到**不相邻**的内存分区中

### 基本分页存储管理方式

分页管理**不会产生外部碎片**，进程只会在为**最后一个不完整块**，申请一个主存块空间时，才产生**主存碎片**

每个进程平均只产生**半个块大小**的内部碎片(页内碎片)

- 页： 进程中的块
- 页框： 内存中的块(页帧)
- 同样的单位，外存中也称为块
- 进程执行时，申请主存空间，为每个页面分配主存中的可用页框，产生了页和页框的一一对应

![地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "地址结构")

页表，**由页表项组成**，系统为每个进程建立一个页表，记录**页面**在内存中对应的**物理块号**

**页表项与地址的区别**

页表项与地址第一部分都是**页号**

页表项的第二部分是**物理内存**中的块号

地址的第二部分是**页内偏移**

页表项的第二部分和地址的第二部分**共同组成物理地址**

基本地址变换机构，由硬件完成

**页式**管理中**地址空间**是**一维**的

#### 缺点

- 地址转换若不够快，导致**访存速度降低**

- 页表若太大，导致**内存利用率降低**

**具有快表的地址变换机构**

- 给出逻辑地址后，**先查快表**，找不到，再查主存

- 找到以后缓存在快表中

**快表基于局部性原理**

#### 两级页表

举个例子，32位逻辑地址，页面大小4KB，页表项大小4B，若要实现进程对全部逻辑地址空间映射，

每个进程需要 2^20 个页表项，4KB = 2^12B，占12位(页内偏移)，32-12=20，即页号占有的位数

每个进程页表这一项，需要 2^20 * 4 = 4MB 主存空间，不切实际，延伸为二级页表，将20位页号，划分为两部分

![两级页表地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png "两级页表地址结构")

### 基本分段存储管理方式

#### 分段

段式管理方式按照用户进程中的自然段划分逻辑空间，**对用户透明**

每个段分配一段连续的地址空间(**段内要求连续，段间不要求连续**)，整个作业的**地址空间**是**二维**的

![分段逻辑地址结构](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/分段逻辑地址结构.png "分段逻辑地址结构")

#### 段表

![段表项](https://github.com/YC-L/Postgraduate-examination/blob/Operating-System/imgs/%E6%AE%B5%E8%A1%A8%E9%A1%B9.png "段表项")

#### 地址变换机构

段表寄存器

#### 段的共享与保护

段的共享是通过**两个作业**的**段表中相应表项**指向被共享的段的**同一个物理副本**来实现的

当一个作业正从共享段中读取数据时，必须**防止另一个作业**修改此共享段中的数据

**不能修改**的代码称为**纯代码**或**可重入代码**

#### 分段管理的保护方法有两种

- 存取控制保护

- 地址越界保护

段式管理不能给出一个整数确定对应的物理地址，段号和段内偏移要**显式**给出

分段管理的**地址空间**是**二维的**

### 段页式管理方式

先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址

进行**一次访问**，需要**三次访问主存**，段页式管理的**地址空间**是**二维**的









## 二叉排序树(二叉搜索树)

### BST，也称二叉查找树，或者是一颗空树，或者是一颗具有下列特性的非空二叉树

- 若左子树非空，则左子树上所有结点关键字值均小于根节点的关键字值

- 若右子树非空，则右子树上所有结点关键字值均大于根节点的关键字值

- 左、右子树本身也分别是一颗二叉排序书

左小右大，对其进行**中序遍历，**得到一个**递增**的有序序列

#### 二叉排序树的查找

- 从根节点开始，沿某一个分支逐层向下进行比较的过程

- 将给定值与根结点的关键字比较，若相等，查找成功

- 若不等，根结点的值大于关键字值时，从左子树查找，否则从右子树查找

```cpp

BSTNode *BST_Search(BiTree T,ElemType key, BSTNode *&p){
	p = NULL;	// p指向被查找结点的双亲，用于插入和删除操作
	while(T != NULL && key != T->data){
		p = T;
		if(key < T->data){
			T=T->lchild;
		}else{
			T=T->rchild;
		}		
	}
	return T;
}

```

#### 二叉排序树的插入

- 二叉排序树作为一种动态集合，树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再插入

##### 插入结点的过程

- 若原二叉排序树为空，则直接插入结点

- 否则，若关键字k小于根结点关键字，则插入到左子树中

- 若关键字k大于根结点关键字，插入到右子树

```cpp

int BST_Insert(BiTree &T, KeyType k){	
	if(T == NULL){		// 原树为空，新插入的记录为根结点
		T = (BiTree)malloc(sizeof(BSTNode));
		T->key = k;
		T->lchild = T->rchild = NULL;
		return 1;
	}else if(k == T->key){
		return 0;	
	}else if(k < T->key){
		return BST_Insert(T->lchild, k);
	}else{
		return BST_Insert(T->rchild, k);
	}	
}

```

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Binary-sort-tree-insertion.png)

#### 二叉树构造

- 依次输入数据元素，并将它们插入到二叉排序树中的适当位置上的过程

- 每读入一个元素，就建立一个新结点，若二叉排序树非空，则将新结点的值与根结点相比较

- 如果小于根结点的值，插入到左子树中；否则插入到右子树中；若为空，新结点作为二叉排序树的根结点

```cpp

void Creat_BST(BiTree &T, KeyType str[], int n){
	// 关键字数组 str[] 建立一个二叉排序树
	T = NULL;
	int i = 0;
	while(i < n){
		BST_Insert(T, str[i]);
		i++;
	}
}

```

#### 二叉排序树的删除

- 在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除

- 必须先把被删除结点从二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来

##### 删除操作的实现过程按3种情况来处理

- 如果被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质

- 若结点z只有一颗左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置

- 若结点z有左、右两颗子树，则令z的直接后继(或直接前驱)替代z，然后从二叉排序树中删除这个直接后继(直接前驱)，转化成第一或者第二种情况

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Binary-sort-tree-Deletion.png)

#### 二叉排序树的查找效率分析

- 对于高度为H的二叉排序树，插入和删除操作的运行时间都是O(H)

- 最坏的情况下，构造二叉排序树的输入序列是有序的，会形成一个倾斜的单支树

- 此时二叉排序树的性能显著变坏，树的高度也增加为元素个数N

- 二叉排序树查找算法的平均查找长度，主要取决于树的高度，与二叉树形态有关

- 如果二叉排序树是一棵只有右(左)孩子的单支树，平均查找长度与单链表相同，为O(n)

- 如果二叉排序树的左、右子树高度差绝对值不超过1，称为**平衡二叉树**，平均查找长度达到O(log2n)

#### 维护表的有序性而言，二叉排序书无须移动结点，只需修改指针即可完成插入和删除操作

### 典型例题

- 对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是()

- 95， 22， 91， 24， 94， 71
- 92， 20， 91， 34， 88， 35
- 21， 89， 77， 29， 36， 38
- 12， 25， 71， 68， 33， 34

- 沿着左小右大画出折线路径，判断结果A不可能





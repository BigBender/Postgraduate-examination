## 散列表

### 基本概念

查找方法建立在"比较"的基础上，查找的效率取决于比较的次数

**散列函数**：

一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr

散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为"冲突"，这些发生碰撞的不同关键字称为 **同义词**

**散列表**：

根据关键字而直接进行访问的数据结构，也就是说散列表建立了关键字和存储地址之间的一种直接映射关系

理想情况下，对散列表进行查找的时间复杂度为O(1)，与表中元素个数无关

### 散列函数的构造方法

1. 散列函数定义域必须包含全部需要存储的关键字，而值域的范围依赖于散列表的大小或地址范围
2. 散列函数计算出来的地址能等概率、均匀地分布在整个地址空间，从而减少冲突发生
3. 散列函数尽量简单，能够在较短时间内计算出任一关键字对应的散列地址

#### 直接定址法

H(key)=a*key+b，式中，a和b是常数，计算最简单，不会产生冲突。

适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，造成存储空间浪费

#### 除留余数法

假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字 转换成散列地址

散列函数为 H(key)=key%p

该方法的**关键是选好p**，使得每一个关键字通过该函数转换后等概率映射到散列空间上的任一地址

#### 数字分析法

设关键字是r进制数，r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码均匀分布较为均匀的若干位作为散列地址

适合于已知的关键字集合

#### 平方取中法

取关键字的平方值得中间几位作为散列地址。具体取多少位看实际情况而定

#### 折叠法

将关键字分割成位数相同的几部分(最后一部分的位数可以短一些)，然后取这基本的叠加和作为散列地址

### 处理冲突的方法

#### 开放定址法

所谓开放定址法，Hi = (H(key)+di)%m，i=0,1,2,...,k(k <= m-1)；m表示散列表表长，di为增量序列

- **线性探测法**

当di=0,1,2,...,m-1，称为线性探测法，冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元

造成大量元素在相邻的散列地址上"聚集"(或堆积起来),大大降低了查找效率

- **平方探测法**

当di=0^2, 1^2, -1^2, 2^2, -2^2,..., k^2, -k^2，其中 k<=m/2，散列表长度m必须是一个可以表示成4k+3的素数，又称二次探测法

平方探测法是一种较好的处理冲突的方法，可以避免出现"堆积"问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元

- **再散列法**

当di=Hash1(Key)时，称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突

再用第二个散列函数Hash2(key)计算该关键字的地址增量

Hi=(H(Key) + i*Hash2(Key))%m

初始探测位置 H0=H(Key)%m，i是冲突的次数，初始为0，在散列法中，最多经过m-1次探测会遍历表中所有位置，回到H0位置

- **伪随机序列法**

当 di=伪随机数序列，称为伪随机序列法

#### 在开放定址的情形下，不能随便物理删除表中已有元素，因为若删除元素将会截断其他具有相同散列地址的元素的查找地址

若想删除一个元素，给她做一个删除标记，进行逻辑删除，副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置没有利用，需要定期维护散列表，把删除标记的元素物理删除

### 拉链法(链接法，chaining)

对于不同的关键字可能通过散列函数映射到同一地址，为了避免非同义词发生冲突，把所有同义词存储在一个线性链表中，由散列地址唯一表示。

拉链法适用于经常进行插入和删除的情况

例如，关键字序列为{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数H(key)=key%13，

拉链法

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Chaining.png)

线性探测处理冲突

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Linear-detection.png)





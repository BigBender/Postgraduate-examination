## 散列表

### 基本概念

- 查找方法建立在"比较"的基础上，查找的效率取决于比较的次数

**散列函数**：

- 一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr

- 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为"**冲突**"

- 这些发生碰撞的不同关键字称为 **同义词**

**散列表**：

- 根据关键字而直接进行访问的数据结构，也就是说散列表建立了关键字和存储地址之间的一种直接映射关系

- 理想情况下，对散列表进行查找的**时间复杂度为O(1)**，与表中元素个数无关

### 散列函数的构造方法

- 散列函数定义域必须包含全部需要存储的关键字，而值域的范围依赖于散列表的大小或地址范围

- 散列函数计算出来的地址能等概率、均匀地分布在整个地址空间，从而减少冲突发生

- 散列函数尽量简单，能够在较短时间内计算出任一关键字对应的散列地址

#### 直接定址法

- H(key)=a*key+b，式中，a和b是常数，计算最简单，不会产生冲突。

- 适合关键字的**分布基本连续**的情况，若关键字分布不连续，空位较多，造成存储空间浪费

#### 除留余数法

- 假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字 转换成散列地址

- 散列函数为 H(key)=key%p

该方法的**关键是选好p**，使得每一个关键字通过该函数转换后等概率映射到散列空间上的任一地址

#### 数字分析法

- 设关键字是r进制数，r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等

- 而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码均匀分布较为均匀的若干位作为散列地址

- 适合于已知的关键字集合

#### 平方取中法

- 取关键字的平方值得中间几位作为散列地址。具体取多少位看实际情况而定

#### 折叠法

- 将关键字分割成位数相同的几部分(最后一部分的位数可以短一些)，然后取这基本的叠加和作为散列地址

### 处理冲突的方法

#### 开放定址法

- 所谓开放定址法，Hi = (H(key)+di)%m，i=0,1,2,...,k(k <= m-1)

- m表示散列表表长，di为增量序列

##### 线性探测法

- 当di=0,1,2,...,m-1，称为线性探测法，冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元

- 造成大量元素在相邻的散列地址上"**聚集**"(或**堆积**起来),大大**降低了查找效率**

##### 平方探测法

- 当di=0^2, 1^2, -1^2, 2^2, -2^2,..., k^2, -k^2，其中 k<=m/2，散列表长度m必须是一个可以表示成4k+3的素数，又称二次探测法

- 平方探测法是一种较好的处理冲突的方法，可以**避免出现"堆积"问题**，它的缺点是**不能探测到散列表上的所有单元**，但至少能探测到一半单元

##### 双散列法

- 当di=Hash1(Key)时，称为双散列法。需要使用两个散列函数，当通过**第一个散列函数H(Key)得到的地址发生冲突**

- 再用第二个散列函数Hash2(key)计算该关键字的**地址增量**

- Hi=(H(Key) + i*Hash2(Key))%m

- 初始探测位置 H0=H(Key)%m，i是冲突的次数，初始为0，在散列法中，**最多经过m-1次探测**会遍历表中所有位置，回到H0位置

- 按照一定距离，跳跃式寻找"下一个"空闲位置，**减少聚集可能**

##### 伪随机序列法

- 当 di=伪随机数序列，称为伪随机序列法

#### 删除元素

- 在开放定址的情形下，不**能随便物理删除表中已有元素**，因为若删除元素将会**截断**其他具有相同散列地址的元素的**查找地址**

- 若想删除一个元素，给它做一个删除标记，进行**逻辑删除**，副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置没有利用，**需要定期维护散列表**，把删除标记的元素**物理删除**

#### 拉链法(链接法，chaining)

- 对于不同的关键字可能通过散列函数映射到同一地址，为了避免非同义词发生冲突，把所有同义词存储在一个线性链表中，由散列地址唯一表示。

- 拉链法适用于经常进行插入和删除的情况

- 例如，关键字序列为{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数H(key)=key%13，

- 拉链法

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Chaining.png)

- 线性探测处理冲突

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Linear-detection.png)

### 散列查找及性能分析

- 散列表的查找过程与构造散列表的过程基本一致

- 对于一个给定的的关键字key，根据散列函数计算散列地址

- 初始化 Addr=Hash(key)

- 检测查找表中地址为Addr的位置上是否有记录

- 若没有，返回查找失败；若有，比较它与key的值，若相等，返回查找成功标志，否则向下

- 用给定的处理冲突方法计算"下一个散列地址"

#### 散列表的查找效率取决于三个因素

- 散列函数

- 处理冲突的方法

- 装填因子

#### 装填因子

- 装填因子一般记为α，定义一个表的**装满程度**， α=n/m (n: 表中记录数n，m: 散列表长度)

- 散列表的**平均查找长度 *依赖*** 于散列表的**装填因子α**，不直接依赖于n或m

- α越大，表示装填的记录**越"满"**，发生冲突的可能性**越大**，反之发生冲突的可能性越小

- 以**平均查找长度**作为**衡量散列表的查找效率的度量**

#### 同义词和非同义词

- 同义词，根据散列函数计算出的散列地址相同的关键字

- 非同义词，根据散列函数计算出的散列地址相同的关键字

### 典型例题

#### 装填因子定义

- 设有一个含有200个表项的散列表，用线性探测法解决冲突

- 按关键字查询时找到一个表项的平均探测次数不超过1.5

- 则散列表应能够容纳 个表项(设查找成功的平均查找长度为ASL=[1+1/(1-α)]/2)

- 如果有200个表项要放入散列表，采用线性探测法解决冲突，限定查找成功的平均查找长度不超过1.5，

- ASL成功=(1 + 1/(1-α))/2 ≤ 1.5 => α=200/m≤1/2 => m≥400

- 假定有K个关键字互为同义词，若用线性探测法把这K个关键字填入散列表中，至少要进行 K(K+1)/2次探测

#### 同义词和非同义词

- 在采用链条地址法处理冲突所构成散列表上查找某一关键字

- 在查找成功的情况下，**所探测的位置上的键值**，一定都是**同义词**

- 若采用线性探测法，则**不一定**都是同义词

#### 删除元素

- 若在散列表中删除一个记录，**在拉链法情况下可以物理地删除**

- 但在开放定址法情况下，**不能物理地删除**，只能作删除标记

- 该地址可**能是该记录地同义词查找路径上的地址**，物理地删除就中断了查找路径

- 查找时碰到空地址就认为是查找失败

- 








## B树(多路平衡查找树)

### 采用B-树和B+树目的

- 应文件系统的要求而发展起来的，**大量数据存放在外存中**，通常存放在硬盘中

- 由于是海量数据，不可能一次调入内存，因此，要多次访问外存

- 硬盘的驱动受机械运动的制约，速度慢。所以，**主要矛盾变为减少访外存次数**

#### B树的阶

- B树中所有结点的孩子结点数的最大值称为B树的阶，通常用m表示

#### 一颗m阶B树或为空树，或为满足如下特性的m叉树

- 树中每个结点至多有m棵子树(至多含有m-1个关键字)

- 若根结点不是终端结点，则至少有两颗子树

- 除根结点外所有非叶结点至少有 ⌈m/2⌉ 棵子树(至少含有⌈m/2⌉-1个关键字)

- 所有非叶结点的结构如下：

<table>
	<tr>
		<td>n</td>
		<td>0</td>
		<td>K1</td>
		<td>P1</td>
		<td>K2</td>
		<td>P2</td>
		<td>...</td>
		<td>Kn</td>
		<td>Pn</td>
	</tr>
</table>

- 其中，Ki(i=1,2...,n)为结点的关键字，且满足K1<K2<...<Kn；Pi(i=0,1,...,n)为指向子树根结点的指针，且指针Pi-1所指子树中所有结点的关键字均小于Ki，Pi所指子树中所有结点的关键字均大于Ki，n(⌈m/2⌉-1<=n<=m-1)

- 所有的叶结点都出现在同一层次上，并且不带信息

- B树是所有结点的平衡因子均等于0的多路查找树，底层方形结点表示叶结点，这些结点中没有存储任何信息

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/B-tree.png)

### B树的高度(磁盘存取次数)

- 大部分操作所需的**磁盘存取次数与B树的高度成正比**

- B树的高度**不包括**最后的不带任何信息的叶结点所处的那一层

- 如果 n>=1，则对任意一颗包含n个关键字、高度为h、阶数为m的B树

- B树中每个结点最多有m棵子树，m-1个关键字，所以在一颗高度为h的m阶B树中关键字的个数应满足 n <= (m-1)*(1+m+m^2+...+m^(h-1))=m^h - 1

- h >= logm (n+1)

- 若让每个结点上的**关键字个数达到最少**，则容纳**同样多关键字的B树的高度可达到最大**

- 由B树的定义：第一层至少有一个结点；第二层至少有两个结点；

- 除根结点以外的每个非终端结点至少有⌈m/2⌉棵子树，则第一层至少有⌈m/2⌉棵子树，第二层至少有2⌈m/2⌉棵子树...第h+1层至少有2(⌈m/2⌉)^(h-1)

- 对于关键字个数为n的B树，叶结点即查找不成功的结点为n+1，由此有n+1>=2(⌈m/2⌉)^(h-1)

- h<=log⌈m/2⌉ ((n+1)/2)+1

### B树的查找

- B树上进行查找与二叉查找树很相似，每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支查找，而是根据该结点的子树所做的多路分支决定

#### B树查找包含两个基本操作

- 在B树中查找结点

- 在结点内找关键字

- B树常存储在磁盘上，则前一个查找操作是在**磁盘**上进行，而后一个查找操作是在**内存**中进行的

- 在找到目标结点后，**先将结点中的信息读入内存**，然后再采用顺序查找法或折半查找法等于K的关键字

- 在B树上查找到某个结点后，**先在有序表中**进行查找，若找到则查找成功，**否则按照对应的指针**信息到所指的子树中查找

### B树的插入

- 与二叉排序树得插入操作相比，B树的插入操作复杂得多

- 在二叉排序树中，仅需查找到需插入得终端结点得位置

- 但在B树种找到插入位置以后，不能简单地将其添加到终端结点中去，可能导致整棵树不再满足B树中定义中的要求

#### 将关键字key插入到B树过程如下

- 定位：利用前述的B树查找算法，找出插入该关键字的最底层中某个非叶结点

- 插入：在B树种，每个非失败结点的关键字个数在[⌈m/2⌉-1， m-1]之间
</br>当插入后的结点关键字个数小于m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m-1，则必须对结点进行分裂

#### 分裂的方法

- 取一个新结点，将插入key后的原结点从中间位置将其中的关键字分为两部分，**左部分包含的关键字放在原结点**，**右部分包含的关键字放到新的结点**，**中间位置(⌈m/2⌉)插入的原结点的父**节点

- 若导致**父结点关键字个数超过上限**，则**继续进行这种分裂操作**，直至这个过程传到根结点为止，导致B树高度增1

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Node-splitting.png)

### B树的删除

- 删除和插入类似，稍微复杂些，要使得删除后的结点中的关键字个数 >= ⌈m/2⌉-1，涉及到结点"合并"问题

- **当被删除的关键字在非终端结点**

- 如果小于k的子树中关键字个数>⌈m/2⌉-1，找出k的前驱值k'，用k'代替k，再递归删除k'即可

- 如果大于k地子树中关键字个数>⌈m/2⌉-1，找出k地后继值k'，用k'代替k，再递归删除k'即可

- 如果前后两个子树中关键字个数均为⌈m/2⌉-1，则直接将两个子结点合并，直接删除k即可

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/B-tree-deletion.png)

- **当被删除的关键字在终端结点**

- 直接删除关键字：若被删除关键字所在结点的关键字>⌈m/2⌉-1，表明该关键字仍满足B树的定义，直接删去关键字
- 兄弟够借：若被删除关键字所在结点删除前的关键字个数=⌈m/2⌉-1，且与此结点相邻的右(左)兄弟结点的关键字个数>=⌈m/2⌉，需要调整该结点、右(左)兄弟结点以及双亲结点(父子换位法)，以达到新的平衡

- 兄弟不够借：若被删除关键字所在结点删除前的关键字个数=⌈m/2⌉-1，此时与该结点相邻的右(左)兄弟结点的关键字个数=⌈m/2⌉-1，将关键字删除后与右(左)兄弟结点及其双亲结点的关键字进行合并

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/B-tree-deletion-on-node.png)

#### 删除过程中，兄弟够借，兄弟拿上去，双亲拿下来合并到结点；兄弟不够借，双亲拿下来与兄弟结点合并

- 在合并过程中，双亲结点中的关键字个数会减少

- 若其双亲结点是根结点并且关键字个数减少至0(根结点关键字个数为1时，有2个子树)，直接将根结点删除，合并后的新结点成为根

- 若双亲结点不是根结点，且关键字个数减少到⌈m/2⌉-2，又要把它自己的兄弟结点进行调整或合并操作，重复上述过程，直到符合B树的要求为止









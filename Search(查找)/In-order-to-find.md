## 顺序查找

### 又称线性查找，主要用于在线性表中进行查找

顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的顺序表的顺序查找

### 一般线性表的顺序查找

从线性表的一端开始，逐个检查关键字是否满足给定的条件

若已经查找到表的另一端，还没有查找到符合给定条件的元素，则返回查找失败的信息

### 引入"哨兵"

```cpp

typedef struct{		// 查找表的数据结构
	ElemType *elem;	// 元素存储空间基址，建表时按实际长度分配，0号单元留空
	int TableLen;	// 表长度
}SSTable;

int Search_Seq(SSTable ST, ElemType key){
	// 顺序表ST中顺序查找关键字为key的元素，若找到返回该元素在表中的位置
	ST.elem[0] = key;	// 哨兵
	for(int i = ST.TableLen;ST.elem[i]!=key;--i);	
	return i;
}

```

上述算法中，将ST.elem[0]称为哨兵，引入目的是使得Search_Seq内的循环不必判断数组是否越界，引入"哨兵"避免不必要的判断语句，提高程序效率

对于有n个元素的表，给定值key与表中第i个元素的关键字相等，即定位第i个元素时，需进行n-i+1次关键字的比较，即Ci = n-i+1

查找成功时 ASL = ∑ Pi(n-i+1)，i=1,2,...n

当每个元素查找概率相等时，即Pi=1/n，则有 ASL = ∑ Pi(n-i+1)=n+1/2，i=1,2,...n

查找不成功时，与表中各关键字的比较次数显然是n+1次，从而顺序查找不成功的平均查找长度为 ASl = n+1

查找表中记录的查找概率不相等，若能预知每个记录的查找概率，应先对记录的查找概率排序，从小到达重排

#### 优缺点 

- 顺序查找缺点，当n较大，平均查找长度较大，效率低

- 优点对数据元素的存储没有要求，顺序存储或链式存储皆可

### 有序表的顺序查找

假设表L是按关键字从小到大排列的，查找的顺序从前往后查找
待查找元素的关键字为key，当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，就可以返回查找失败的信息

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/In-order-to-find.png)

树中圆形结点表示有序顺序表中存在的元素，矩形结点表示失败结点

失败结点是虚构的空结点，到达失败结点所查找的长度等于它上面一个圆形结点所在层数

查找不成功的平均查找长度在相等查找概率情形下有

ASL = ∑ qj(lj - 1) = 1+2+...n+n/n+1=n/2 + n/n+1

比一般的顺序查找算法好一些



## 折半查找(二分查找)

### 仅适用于有序的顺序表

- 首先将给定值key与表中中间位置元素的关键字比较，若相等，查找成功，返回该元素的存储位置

- 若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中

- 然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需查找的元素

```cpp

int Binary_Search(SeqList L, ElemType key){
	int low = 0, high = L.TableLen-1, mid;
	while(low <= high){
		mid = (low + hight)/2;
		if(L.elem[mid] == key){
			return mid;
		}else if(L.elem[mid] > key){
			high = mid-1;			// 从前半部分继续查找
		}else{
			low = mid+1;			// 从后半部分继续查找
		}
	}
	return -1;
}

```

#### 折半查找过程的判定树(左小右大)

![image](https://github.com/YC-L/Postgraduate-examination/blob/DataStructure/imgs/Half-interval-search.png)

- **圆形结点**(内部结点)表示一个记录，结点中的值为该记录的关键字值

- **矩形结点**(外部结点)表示**查找不成功**的情况

- 查找成功时，查找长度为从根结点到目的结点的路径上的结点数

- 查找不成功时的查找长度为从根结点对应失败结点的父结点路径上的结点数

- 有序序列有n个元素，对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点

#### 查找成功平均查找长度

ASL=1/n ∑ li = 1/n(1*1 + 2*2 + ... + h*2^(h-1))=n+1/nlog2(n+1) - 1≈log2(n+1)-1

#### 查找第i个元素所与关键字比较的次数

- 是从根到该结点路径上的结点数，也即是该结点在树上的层次数

- 查找成功时，进行比较的关键字个数**最多不超过树的深度**

- 具有n个结点的判定树的深度为 ⌊log2n⌋ + 1

- 折半查找在查找成功时和给定值比较的关键字个数至多为 ⌊log2n⌋ + 1

- 折半查找在查找不成功时和给定值比较的关键字个数至多为 ⌊log2n⌋ + 1

#### 仅适合于线性表的顺相互存储结构，不适合链式存储结构，切要求元素按关键字有序排列

- 因为折半查找需要方便定位查找区域，适合折半查找的存储结构必须具有随机存取的特性

#### 时间复杂度 O(log2n)，平均情况下比顺序查找效率高

#### 典型例题

- 已知一个长度为16的顺序表L，元素按关键字有序排列，若采用折半查找法查找一个L中不存在的元素，则关键字的比较次数是 ⌊log2n⌋ + 1
- 根据折半查找判定树的高度可以得到，比较次数








